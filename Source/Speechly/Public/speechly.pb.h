// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: speechly.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_speechly_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_speechly_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_speechly_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_speechly_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_speechly_2eproto;
namespace v1 {
class EntityEvent;
class EntityEventDefaultTypeInternal;
extern EntityEventDefaultTypeInternal _EntityEvent_default_instance_;
class IntentEvent;
class IntentEventDefaultTypeInternal;
extern IntentEventDefaultTypeInternal _IntentEvent_default_instance_;
class LoginRequest;
class LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
class LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class SLUConfig;
class SLUConfigDefaultTypeInternal;
extern SLUConfigDefaultTypeInternal _SLUConfig_default_instance_;
class SLUError;
class SLUErrorDefaultTypeInternal;
extern SLUErrorDefaultTypeInternal _SLUError_default_instance_;
class SLUEvent;
class SLUEventDefaultTypeInternal;
extern SLUEventDefaultTypeInternal _SLUEvent_default_instance_;
class SLUFinished;
class SLUFinishedDefaultTypeInternal;
extern SLUFinishedDefaultTypeInternal _SLUFinished_default_instance_;
class SLURequest;
class SLURequestDefaultTypeInternal;
extern SLURequestDefaultTypeInternal _SLURequest_default_instance_;
class SLUResponse;
class SLUResponseDefaultTypeInternal;
extern SLUResponseDefaultTypeInternal _SLUResponse_default_instance_;
class SLUStarted;
class SLUStartedDefaultTypeInternal;
extern SLUStartedDefaultTypeInternal _SLUStarted_default_instance_;
class SegmentEndEvent;
class SegmentEndEventDefaultTypeInternal;
extern SegmentEndEventDefaultTypeInternal _SegmentEndEvent_default_instance_;
class TentativeEntitiesEvent;
class TentativeEntitiesEventDefaultTypeInternal;
extern TentativeEntitiesEventDefaultTypeInternal _TentativeEntitiesEvent_default_instance_;
class TentativeTranscriptEvent;
class TentativeTranscriptEventDefaultTypeInternal;
extern TentativeTranscriptEventDefaultTypeInternal _TentativeTranscriptEvent_default_instance_;
class TranscriptEvent;
class TranscriptEventDefaultTypeInternal;
extern TranscriptEventDefaultTypeInternal _TranscriptEvent_default_instance_;
class WLURequest;
class WLURequestDefaultTypeInternal;
extern WLURequestDefaultTypeInternal _WLURequest_default_instance_;
class WLUResponse;
class WLUResponseDefaultTypeInternal;
extern WLUResponseDefaultTypeInternal _WLUResponse_default_instance_;
}  // namespace v1
PROTOBUF_NAMESPACE_OPEN
template<> ::v1::EntityEvent* Arena::CreateMaybeMessage<::v1::EntityEvent>(Arena*);
template<> ::v1::IntentEvent* Arena::CreateMaybeMessage<::v1::IntentEvent>(Arena*);
template<> ::v1::LoginRequest* Arena::CreateMaybeMessage<::v1::LoginRequest>(Arena*);
template<> ::v1::LoginResponse* Arena::CreateMaybeMessage<::v1::LoginResponse>(Arena*);
template<> ::v1::SLUConfig* Arena::CreateMaybeMessage<::v1::SLUConfig>(Arena*);
template<> ::v1::SLUError* Arena::CreateMaybeMessage<::v1::SLUError>(Arena*);
template<> ::v1::SLUEvent* Arena::CreateMaybeMessage<::v1::SLUEvent>(Arena*);
template<> ::v1::SLUFinished* Arena::CreateMaybeMessage<::v1::SLUFinished>(Arena*);
template<> ::v1::SLURequest* Arena::CreateMaybeMessage<::v1::SLURequest>(Arena*);
template<> ::v1::SLUResponse* Arena::CreateMaybeMessage<::v1::SLUResponse>(Arena*);
template<> ::v1::SLUStarted* Arena::CreateMaybeMessage<::v1::SLUStarted>(Arena*);
template<> ::v1::SegmentEndEvent* Arena::CreateMaybeMessage<::v1::SegmentEndEvent>(Arena*);
template<> ::v1::TentativeEntitiesEvent* Arena::CreateMaybeMessage<::v1::TentativeEntitiesEvent>(Arena*);
template<> ::v1::TentativeTranscriptEvent* Arena::CreateMaybeMessage<::v1::TentativeTranscriptEvent>(Arena*);
template<> ::v1::TranscriptEvent* Arena::CreateMaybeMessage<::v1::TranscriptEvent>(Arena*);
template<> ::v1::WLURequest* Arena::CreateMaybeMessage<::v1::WLURequest>(Arena*);
template<> ::v1::WLUResponse* Arena::CreateMaybeMessage<::v1::WLUResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace v1 {

enum SLUConfig_Encoding : int {
  SLUConfig_Encoding_LINEAR16 = 0,
  SLUConfig_Encoding_SLUConfig_Encoding_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SLUConfig_Encoding_SLUConfig_Encoding_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SLUConfig_Encoding_IsValid(int value);
constexpr SLUConfig_Encoding SLUConfig_Encoding_Encoding_MIN = SLUConfig_Encoding_LINEAR16;
constexpr SLUConfig_Encoding SLUConfig_Encoding_Encoding_MAX = SLUConfig_Encoding_LINEAR16;
constexpr int SLUConfig_Encoding_Encoding_ARRAYSIZE = SLUConfig_Encoding_Encoding_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLUConfig_Encoding_descriptor();
template<typename T>
inline const std::string& SLUConfig_Encoding_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLUConfig_Encoding>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLUConfig_Encoding_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLUConfig_Encoding_descriptor(), enum_t_value);
}
inline bool SLUConfig_Encoding_Parse(
    const std::string& name, SLUConfig_Encoding* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLUConfig_Encoding>(
    SLUConfig_Encoding_descriptor(), name, value);
}
enum SLUEvent_Event : int {
  SLUEvent_Event_START = 0,
  SLUEvent_Event_STOP = 1,
  SLUEvent_Event_SLUEvent_Event_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SLUEvent_Event_SLUEvent_Event_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SLUEvent_Event_IsValid(int value);
constexpr SLUEvent_Event SLUEvent_Event_Event_MIN = SLUEvent_Event_START;
constexpr SLUEvent_Event SLUEvent_Event_Event_MAX = SLUEvent_Event_STOP;
constexpr int SLUEvent_Event_Event_ARRAYSIZE = SLUEvent_Event_Event_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SLUEvent_Event_descriptor();
template<typename T>
inline const std::string& SLUEvent_Event_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SLUEvent_Event>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SLUEvent_Event_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SLUEvent_Event_descriptor(), enum_t_value);
}
inline bool SLUEvent_Event_Parse(
    const std::string& name, SLUEvent_Event* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SLUEvent_Event>(
    SLUEvent_Event_descriptor(), name, value);
}
// ===================================================================

class SLURequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.SLURequest) */ {
 public:
  SLURequest();
  virtual ~SLURequest();

  SLURequest(const SLURequest& from);
  SLURequest(SLURequest&& from) noexcept
    : SLURequest() {
    *this = ::std::move(from);
  }

  inline SLURequest& operator=(const SLURequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLURequest& operator=(SLURequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SLURequest& default_instance();

  enum StreamingRequestCase {
    kConfig = 1,
    kEvent = 2,
    kAudio = 3,
    STREAMING_REQUEST_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLURequest* internal_default_instance() {
    return reinterpret_cast<const SLURequest*>(
               &_SLURequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SLURequest* other);
  friend void swap(SLURequest& a, SLURequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLURequest* New() const final {
    return CreateMaybeMessage<SLURequest>(nullptr);
  }

  SLURequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SLURequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SLURequest& from);
  void MergeFrom(const SLURequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLURequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.SLURequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_speechly_2eproto);
    return ::descriptor_table_speechly_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .v1.SLUConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::v1::SLUConfig& config() const;
  ::v1::SLUConfig* release_config();
  ::v1::SLUConfig* mutable_config();
  void set_allocated_config(::v1::SLUConfig* config);

  // .v1.SLUEvent event = 2;
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 2;
  const ::v1::SLUEvent& event() const;
  ::v1::SLUEvent* release_event();
  ::v1::SLUEvent* mutable_event();
  void set_allocated_event(::v1::SLUEvent* event);

  // bytes audio = 3;
  private:
  bool has_audio() const;
  public:
  void clear_audio();
  static const int kAudioFieldNumber = 3;
  const std::string& audio() const;
  void set_audio(const std::string& value);
  void set_audio(std::string&& value);
  void set_audio(const char* value);
  void set_audio(const void* value, size_t size);
  std::string* mutable_audio();
  std::string* release_audio();
  void set_allocated_audio(std::string* audio);

  void clear_streaming_request();
  StreamingRequestCase streaming_request_case() const;
  // @@protoc_insertion_point(class_scope:v1.SLURequest)
 private:
  class HasBitSetters;
  void set_has_config();
  void set_has_event();
  void set_has_audio();

  inline bool has_streaming_request() const;
  inline void clear_has_streaming_request();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union StreamingRequestUnion {
    StreamingRequestUnion() {}
    ::v1::SLUConfig* config_;
    ::v1::SLUEvent* event_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_;
  } streaming_request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_speechly_2eproto;
};
// -------------------------------------------------------------------

class SLUConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.SLUConfig) */ {
 public:
  SLUConfig();
  virtual ~SLUConfig();

  SLUConfig(const SLUConfig& from);
  SLUConfig(SLUConfig&& from) noexcept
    : SLUConfig() {
    *this = ::std::move(from);
  }

  inline SLUConfig& operator=(const SLUConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUConfig& operator=(SLUConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SLUConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLUConfig* internal_default_instance() {
    return reinterpret_cast<const SLUConfig*>(
               &_SLUConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SLUConfig* other);
  friend void swap(SLUConfig& a, SLUConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLUConfig* New() const final {
    return CreateMaybeMessage<SLUConfig>(nullptr);
  }

  SLUConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SLUConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SLUConfig& from);
  void MergeFrom(const SLUConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLUConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.SLUConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_speechly_2eproto);
    return ::descriptor_table_speechly_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SLUConfig_Encoding Encoding;
  static constexpr Encoding LINEAR16 =
    SLUConfig_Encoding_LINEAR16;
  static inline bool Encoding_IsValid(int value) {
    return SLUConfig_Encoding_IsValid(value);
  }
  static constexpr Encoding Encoding_MIN =
    SLUConfig_Encoding_Encoding_MIN;
  static constexpr Encoding Encoding_MAX =
    SLUConfig_Encoding_Encoding_MAX;
  static constexpr int Encoding_ARRAYSIZE =
    SLUConfig_Encoding_Encoding_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Encoding_descriptor() {
    return SLUConfig_Encoding_descriptor();
  }
  template<typename T>
  static inline const std::string& Encoding_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Encoding>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Encoding_Name.");
    return SLUConfig_Encoding_Name(enum_t_value);
  }
  static inline bool Encoding_Parse(const std::string& name,
      Encoding* value) {
    return SLUConfig_Encoding_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string language_code = 4;
  void clear_language_code();
  static const int kLanguageCodeFieldNumber = 4;
  const std::string& language_code() const;
  void set_language_code(const std::string& value);
  void set_language_code(std::string&& value);
  void set_language_code(const char* value);
  void set_language_code(const char* value, size_t size);
  std::string* mutable_language_code();
  std::string* release_language_code();
  void set_allocated_language_code(std::string* language_code);

  // .v1.SLUConfig.Encoding encoding = 1;
  void clear_encoding();
  static const int kEncodingFieldNumber = 1;
  ::v1::SLUConfig_Encoding encoding() const;
  void set_encoding(::v1::SLUConfig_Encoding value);

  // int32 channels = 2;
  void clear_channels();
  static const int kChannelsFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 channels() const;
  void set_channels(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 sample_rate_hertz = 3;
  void clear_sample_rate_hertz();
  static const int kSampleRateHertzFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 sample_rate_hertz() const;
  void set_sample_rate_hertz(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:v1.SLUConfig)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_code_;
  int encoding_;
  ::PROTOBUF_NAMESPACE_ID::int32 channels_;
  ::PROTOBUF_NAMESPACE_ID::int32 sample_rate_hertz_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2eproto;
};
// -------------------------------------------------------------------

class SLUEvent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.SLUEvent) */ {
 public:
  SLUEvent();
  virtual ~SLUEvent();

  SLUEvent(const SLUEvent& from);
  SLUEvent(SLUEvent&& from) noexcept
    : SLUEvent() {
    *this = ::std::move(from);
  }

  inline SLUEvent& operator=(const SLUEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUEvent& operator=(SLUEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SLUEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLUEvent* internal_default_instance() {
    return reinterpret_cast<const SLUEvent*>(
               &_SLUEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SLUEvent* other);
  friend void swap(SLUEvent& a, SLUEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLUEvent* New() const final {
    return CreateMaybeMessage<SLUEvent>(nullptr);
  }

  SLUEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SLUEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SLUEvent& from);
  void MergeFrom(const SLUEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLUEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.SLUEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_speechly_2eproto);
    return ::descriptor_table_speechly_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SLUEvent_Event Event;
  static constexpr Event START =
    SLUEvent_Event_START;
  static constexpr Event STOP =
    SLUEvent_Event_STOP;
  static inline bool Event_IsValid(int value) {
    return SLUEvent_Event_IsValid(value);
  }
  static constexpr Event Event_MIN =
    SLUEvent_Event_Event_MIN;
  static constexpr Event Event_MAX =
    SLUEvent_Event_Event_MAX;
  static constexpr int Event_ARRAYSIZE =
    SLUEvent_Event_Event_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Event_descriptor() {
    return SLUEvent_Event_descriptor();
  }
  template<typename T>
  static inline const std::string& Event_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Event>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Event_Name.");
    return SLUEvent_Event_Name(enum_t_value);
  }
  static inline bool Event_Parse(const std::string& name,
      Event* value) {
    return SLUEvent_Event_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .v1.SLUEvent.Event event = 1;
  void clear_event();
  static const int kEventFieldNumber = 1;
  ::v1::SLUEvent_Event event() const;
  void set_event(::v1::SLUEvent_Event value);

  // @@protoc_insertion_point(class_scope:v1.SLUEvent)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2eproto;
};
// -------------------------------------------------------------------

class SLUResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.SLUResponse) */ {
 public:
  SLUResponse();
  virtual ~SLUResponse();

  SLUResponse(const SLUResponse& from);
  SLUResponse(SLUResponse&& from) noexcept
    : SLUResponse() {
    *this = ::std::move(from);
  }

  inline SLUResponse& operator=(const SLUResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUResponse& operator=(SLUResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SLUResponse& default_instance();

  enum StreamingResponseCase {
    kTranscript = 1,
    kEntity = 2,
    kIntent = 3,
    kSegmentEnd = 4,
    kTentativeTranscript = 5,
    kTentativeEntities = 6,
    kTentativeIntent = 7,
    kStarted = 8,
    kFinished = 9,
    STREAMING_RESPONSE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLUResponse* internal_default_instance() {
    return reinterpret_cast<const SLUResponse*>(
               &_SLUResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SLUResponse* other);
  friend void swap(SLUResponse& a, SLUResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLUResponse* New() const final {
    return CreateMaybeMessage<SLUResponse>(nullptr);
  }

  SLUResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SLUResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SLUResponse& from);
  void MergeFrom(const SLUResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLUResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.SLUResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_speechly_2eproto);
    return ::descriptor_table_speechly_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .v1.TranscriptEvent transcript = 1;
  bool has_transcript() const;
  void clear_transcript();
  static const int kTranscriptFieldNumber = 1;
  const ::v1::TranscriptEvent& transcript() const;
  ::v1::TranscriptEvent* release_transcript();
  ::v1::TranscriptEvent* mutable_transcript();
  void set_allocated_transcript(::v1::TranscriptEvent* transcript);

  // .v1.EntityEvent entity = 2;
  bool has_entity() const;
  void clear_entity();
  static const int kEntityFieldNumber = 2;
  const ::v1::EntityEvent& entity() const;
  ::v1::EntityEvent* release_entity();
  ::v1::EntityEvent* mutable_entity();
  void set_allocated_entity(::v1::EntityEvent* entity);

  // .v1.IntentEvent intent = 3;
  bool has_intent() const;
  void clear_intent();
  static const int kIntentFieldNumber = 3;
  const ::v1::IntentEvent& intent() const;
  ::v1::IntentEvent* release_intent();
  ::v1::IntentEvent* mutable_intent();
  void set_allocated_intent(::v1::IntentEvent* intent);

  // .v1.SegmentEndEvent segment_end = 4;
  bool has_segment_end() const;
  void clear_segment_end();
  static const int kSegmentEndFieldNumber = 4;
  const ::v1::SegmentEndEvent& segment_end() const;
  ::v1::SegmentEndEvent* release_segment_end();
  ::v1::SegmentEndEvent* mutable_segment_end();
  void set_allocated_segment_end(::v1::SegmentEndEvent* segment_end);

  // .v1.TentativeTranscriptEvent tentative_transcript = 5;
  bool has_tentative_transcript() const;
  void clear_tentative_transcript();
  static const int kTentativeTranscriptFieldNumber = 5;
  const ::v1::TentativeTranscriptEvent& tentative_transcript() const;
  ::v1::TentativeTranscriptEvent* release_tentative_transcript();
  ::v1::TentativeTranscriptEvent* mutable_tentative_transcript();
  void set_allocated_tentative_transcript(::v1::TentativeTranscriptEvent* tentative_transcript);

  // .v1.TentativeEntitiesEvent tentative_entities = 6;
  bool has_tentative_entities() const;
  void clear_tentative_entities();
  static const int kTentativeEntitiesFieldNumber = 6;
  const ::v1::TentativeEntitiesEvent& tentative_entities() const;
  ::v1::TentativeEntitiesEvent* release_tentative_entities();
  ::v1::TentativeEntitiesEvent* mutable_tentative_entities();
  void set_allocated_tentative_entities(::v1::TentativeEntitiesEvent* tentative_entities);

  // .v1.IntentEvent tentative_intent = 7;
  bool has_tentative_intent() const;
  void clear_tentative_intent();
  static const int kTentativeIntentFieldNumber = 7;
  const ::v1::IntentEvent& tentative_intent() const;
  ::v1::IntentEvent* release_tentative_intent();
  ::v1::IntentEvent* mutable_tentative_intent();
  void set_allocated_tentative_intent(::v1::IntentEvent* tentative_intent);

  // .v1.SLUStarted started = 8;
  bool has_started() const;
  void clear_started();
  static const int kStartedFieldNumber = 8;
  const ::v1::SLUStarted& started() const;
  ::v1::SLUStarted* release_started();
  ::v1::SLUStarted* mutable_started();
  void set_allocated_started(::v1::SLUStarted* started);

  // .v1.SLUFinished finished = 9;
  bool has_finished() const;
  void clear_finished();
  static const int kFinishedFieldNumber = 9;
  const ::v1::SLUFinished& finished() const;
  ::v1::SLUFinished* release_finished();
  ::v1::SLUFinished* mutable_finished();
  void set_allocated_finished(::v1::SLUFinished* finished);

  void clear_streaming_response();
  StreamingResponseCase streaming_response_case() const;
  // @@protoc_insertion_point(class_scope:v1.SLUResponse)
 private:
  class HasBitSetters;
  void set_has_transcript();
  void set_has_entity();
  void set_has_intent();
  void set_has_segment_end();
  void set_has_tentative_transcript();
  void set_has_tentative_entities();
  void set_has_tentative_intent();
  void set_has_started();
  void set_has_finished();

  inline bool has_streaming_response() const;
  inline void clear_has_streaming_response();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union StreamingResponseUnion {
    StreamingResponseUnion() {}
    ::v1::TranscriptEvent* transcript_;
    ::v1::EntityEvent* entity_;
    ::v1::IntentEvent* intent_;
    ::v1::SegmentEndEvent* segment_end_;
    ::v1::TentativeTranscriptEvent* tentative_transcript_;
    ::v1::TentativeEntitiesEvent* tentative_entities_;
    ::v1::IntentEvent* tentative_intent_;
    ::v1::SLUStarted* started_;
    ::v1::SLUFinished* finished_;
  } streaming_response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_speechly_2eproto;
};
// -------------------------------------------------------------------

class TentativeTranscriptEvent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.TentativeTranscriptEvent) */ {
 public:
  TentativeTranscriptEvent();
  virtual ~TentativeTranscriptEvent();

  TentativeTranscriptEvent(const TentativeTranscriptEvent& from);
  TentativeTranscriptEvent(TentativeTranscriptEvent&& from) noexcept
    : TentativeTranscriptEvent() {
    *this = ::std::move(from);
  }

  inline TentativeTranscriptEvent& operator=(const TentativeTranscriptEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TentativeTranscriptEvent& operator=(TentativeTranscriptEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TentativeTranscriptEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TentativeTranscriptEvent* internal_default_instance() {
    return reinterpret_cast<const TentativeTranscriptEvent*>(
               &_TentativeTranscriptEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(TentativeTranscriptEvent* other);
  friend void swap(TentativeTranscriptEvent& a, TentativeTranscriptEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TentativeTranscriptEvent* New() const final {
    return CreateMaybeMessage<TentativeTranscriptEvent>(nullptr);
  }

  TentativeTranscriptEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TentativeTranscriptEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TentativeTranscriptEvent& from);
  void MergeFrom(const TentativeTranscriptEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TentativeTranscriptEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.TentativeTranscriptEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_speechly_2eproto);
    return ::descriptor_table_speechly_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .v1.TranscriptEvent tentative_words = 2;
  int tentative_words_size() const;
  void clear_tentative_words();
  static const int kTentativeWordsFieldNumber = 2;
  ::v1::TranscriptEvent* mutable_tentative_words(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::TranscriptEvent >*
      mutable_tentative_words();
  const ::v1::TranscriptEvent& tentative_words(int index) const;
  ::v1::TranscriptEvent* add_tentative_words();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::TranscriptEvent >&
      tentative_words() const;

  // string tentative_transcript = 1;
  void clear_tentative_transcript();
  static const int kTentativeTranscriptFieldNumber = 1;
  const std::string& tentative_transcript() const;
  void set_tentative_transcript(const std::string& value);
  void set_tentative_transcript(std::string&& value);
  void set_tentative_transcript(const char* value);
  void set_tentative_transcript(const char* value, size_t size);
  std::string* mutable_tentative_transcript();
  std::string* release_tentative_transcript();
  void set_allocated_tentative_transcript(std::string* tentative_transcript);

  // @@protoc_insertion_point(class_scope:v1.TentativeTranscriptEvent)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::TranscriptEvent > tentative_words_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tentative_transcript_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2eproto;
};
// -------------------------------------------------------------------

class TranscriptEvent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.TranscriptEvent) */ {
 public:
  TranscriptEvent();
  virtual ~TranscriptEvent();

  TranscriptEvent(const TranscriptEvent& from);
  TranscriptEvent(TranscriptEvent&& from) noexcept
    : TranscriptEvent() {
    *this = ::std::move(from);
  }

  inline TranscriptEvent& operator=(const TranscriptEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranscriptEvent& operator=(TranscriptEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TranscriptEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TranscriptEvent* internal_default_instance() {
    return reinterpret_cast<const TranscriptEvent*>(
               &_TranscriptEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(TranscriptEvent* other);
  friend void swap(TranscriptEvent& a, TranscriptEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TranscriptEvent* New() const final {
    return CreateMaybeMessage<TranscriptEvent>(nullptr);
  }

  TranscriptEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TranscriptEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TranscriptEvent& from);
  void MergeFrom(const TranscriptEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranscriptEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.TranscriptEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_speechly_2eproto);
    return ::descriptor_table_speechly_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string audio_context = 1;
  void clear_audio_context();
  static const int kAudioContextFieldNumber = 1;
  const std::string& audio_context() const;
  void set_audio_context(const std::string& value);
  void set_audio_context(std::string&& value);
  void set_audio_context(const char* value);
  void set_audio_context(const char* value, size_t size);
  std::string* mutable_audio_context();
  std::string* release_audio_context();
  void set_allocated_audio_context(std::string* audio_context);

  // string word = 3;
  void clear_word();
  static const int kWordFieldNumber = 3;
  const std::string& word() const;
  void set_word(const std::string& value);
  void set_word(std::string&& value);
  void set_word(const char* value);
  void set_word(const char* value, size_t size);
  std::string* mutable_word();
  std::string* release_word();
  void set_allocated_word(std::string* word);

  // int32 segment_id = 2;
  void clear_segment_id();
  static const int kSegmentIdFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 segment_id() const;
  void set_segment_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 index = 4;
  void clear_index();
  static const int kIndexFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::int32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 start_time = 5;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::int32 start_time() const;
  void set_start_time(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 end_time = 6;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::int32 end_time() const;
  void set_end_time(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:v1.TranscriptEvent)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_context_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr word_;
  ::PROTOBUF_NAMESPACE_ID::int32 segment_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 index_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_time_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2eproto;
};
// -------------------------------------------------------------------

class TentativeEntitiesEvent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.TentativeEntitiesEvent) */ {
 public:
  TentativeEntitiesEvent();
  virtual ~TentativeEntitiesEvent();

  TentativeEntitiesEvent(const TentativeEntitiesEvent& from);
  TentativeEntitiesEvent(TentativeEntitiesEvent&& from) noexcept
    : TentativeEntitiesEvent() {
    *this = ::std::move(from);
  }

  inline TentativeEntitiesEvent& operator=(const TentativeEntitiesEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TentativeEntitiesEvent& operator=(TentativeEntitiesEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TentativeEntitiesEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TentativeEntitiesEvent* internal_default_instance() {
    return reinterpret_cast<const TentativeEntitiesEvent*>(
               &_TentativeEntitiesEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(TentativeEntitiesEvent* other);
  friend void swap(TentativeEntitiesEvent& a, TentativeEntitiesEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TentativeEntitiesEvent* New() const final {
    return CreateMaybeMessage<TentativeEntitiesEvent>(nullptr);
  }

  TentativeEntitiesEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TentativeEntitiesEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TentativeEntitiesEvent& from);
  void MergeFrom(const TentativeEntitiesEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TentativeEntitiesEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.TentativeEntitiesEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_speechly_2eproto);
    return ::descriptor_table_speechly_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .v1.EntityEvent tentative_entities = 1;
  int tentative_entities_size() const;
  void clear_tentative_entities();
  static const int kTentativeEntitiesFieldNumber = 1;
  ::v1::EntityEvent* mutable_tentative_entities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::EntityEvent >*
      mutable_tentative_entities();
  const ::v1::EntityEvent& tentative_entities(int index) const;
  ::v1::EntityEvent* add_tentative_entities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::EntityEvent >&
      tentative_entities() const;

  // @@protoc_insertion_point(class_scope:v1.TentativeEntitiesEvent)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::EntityEvent > tentative_entities_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2eproto;
};
// -------------------------------------------------------------------

class EntityEvent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.EntityEvent) */ {
 public:
  EntityEvent();
  virtual ~EntityEvent();

  EntityEvent(const EntityEvent& from);
  EntityEvent(EntityEvent&& from) noexcept
    : EntityEvent() {
    *this = ::std::move(from);
  }

  inline EntityEvent& operator=(const EntityEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityEvent& operator=(EntityEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EntityEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityEvent* internal_default_instance() {
    return reinterpret_cast<const EntityEvent*>(
               &_EntityEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(EntityEvent* other);
  friend void swap(EntityEvent& a, EntityEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityEvent* New() const final {
    return CreateMaybeMessage<EntityEvent>(nullptr);
  }

  EntityEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EntityEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EntityEvent& from);
  void MergeFrom(const EntityEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.EntityEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_speechly_2eproto);
    return ::descriptor_table_speechly_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string audio_context = 1;
  void clear_audio_context();
  static const int kAudioContextFieldNumber = 1;
  const std::string& audio_context() const;
  void set_audio_context(const std::string& value);
  void set_audio_context(std::string&& value);
  void set_audio_context(const char* value);
  void set_audio_context(const char* value, size_t size);
  std::string* mutable_audio_context();
  std::string* release_audio_context();
  void set_allocated_audio_context(std::string* audio_context);

  // string entity = 3;
  void clear_entity();
  static const int kEntityFieldNumber = 3;
  const std::string& entity() const;
  void set_entity(const std::string& value);
  void set_entity(std::string&& value);
  void set_entity(const char* value);
  void set_entity(const char* value, size_t size);
  std::string* mutable_entity();
  std::string* release_entity();
  void set_allocated_entity(std::string* entity);

  // string value = 4;
  void clear_value();
  static const int kValueFieldNumber = 4;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // int32 segment_id = 2;
  void clear_segment_id();
  static const int kSegmentIdFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 segment_id() const;
  void set_segment_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 start_position = 5;
  void clear_start_position();
  static const int kStartPositionFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::int32 start_position() const;
  void set_start_position(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 end_position = 6;
  void clear_end_position();
  static const int kEndPositionFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::int32 end_position() const;
  void set_end_position(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:v1.EntityEvent)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_context_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entity_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::int32 segment_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_position_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_position_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2eproto;
};
// -------------------------------------------------------------------

class IntentEvent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.IntentEvent) */ {
 public:
  IntentEvent();
  virtual ~IntentEvent();

  IntentEvent(const IntentEvent& from);
  IntentEvent(IntentEvent&& from) noexcept
    : IntentEvent() {
    *this = ::std::move(from);
  }

  inline IntentEvent& operator=(const IntentEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntentEvent& operator=(IntentEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IntentEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IntentEvent* internal_default_instance() {
    return reinterpret_cast<const IntentEvent*>(
               &_IntentEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(IntentEvent* other);
  friend void swap(IntentEvent& a, IntentEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IntentEvent* New() const final {
    return CreateMaybeMessage<IntentEvent>(nullptr);
  }

  IntentEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IntentEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IntentEvent& from);
  void MergeFrom(const IntentEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntentEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.IntentEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_speechly_2eproto);
    return ::descriptor_table_speechly_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string audio_context = 1;
  void clear_audio_context();
  static const int kAudioContextFieldNumber = 1;
  const std::string& audio_context() const;
  void set_audio_context(const std::string& value);
  void set_audio_context(std::string&& value);
  void set_audio_context(const char* value);
  void set_audio_context(const char* value, size_t size);
  std::string* mutable_audio_context();
  std::string* release_audio_context();
  void set_allocated_audio_context(std::string* audio_context);

  // string intent = 3;
  void clear_intent();
  static const int kIntentFieldNumber = 3;
  const std::string& intent() const;
  void set_intent(const std::string& value);
  void set_intent(std::string&& value);
  void set_intent(const char* value);
  void set_intent(const char* value, size_t size);
  std::string* mutable_intent();
  std::string* release_intent();
  void set_allocated_intent(std::string* intent);

  // int32 segment_id = 2;
  void clear_segment_id();
  static const int kSegmentIdFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 segment_id() const;
  void set_segment_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:v1.IntentEvent)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_context_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr intent_;
  ::PROTOBUF_NAMESPACE_ID::int32 segment_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2eproto;
};
// -------------------------------------------------------------------

class SegmentEndEvent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.SegmentEndEvent) */ {
 public:
  SegmentEndEvent();
  virtual ~SegmentEndEvent();

  SegmentEndEvent(const SegmentEndEvent& from);
  SegmentEndEvent(SegmentEndEvent&& from) noexcept
    : SegmentEndEvent() {
    *this = ::std::move(from);
  }

  inline SegmentEndEvent& operator=(const SegmentEndEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentEndEvent& operator=(SegmentEndEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SegmentEndEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SegmentEndEvent* internal_default_instance() {
    return reinterpret_cast<const SegmentEndEvent*>(
               &_SegmentEndEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(SegmentEndEvent* other);
  friend void swap(SegmentEndEvent& a, SegmentEndEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SegmentEndEvent* New() const final {
    return CreateMaybeMessage<SegmentEndEvent>(nullptr);
  }

  SegmentEndEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SegmentEndEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SegmentEndEvent& from);
  void MergeFrom(const SegmentEndEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SegmentEndEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.SegmentEndEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_speechly_2eproto);
    return ::descriptor_table_speechly_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string audio_context = 1;
  void clear_audio_context();
  static const int kAudioContextFieldNumber = 1;
  const std::string& audio_context() const;
  void set_audio_context(const std::string& value);
  void set_audio_context(std::string&& value);
  void set_audio_context(const char* value);
  void set_audio_context(const char* value, size_t size);
  std::string* mutable_audio_context();
  std::string* release_audio_context();
  void set_allocated_audio_context(std::string* audio_context);

  // int32 segment_id = 2;
  void clear_segment_id();
  static const int kSegmentIdFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 segment_id() const;
  void set_segment_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:v1.SegmentEndEvent)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_context_;
  ::PROTOBUF_NAMESPACE_ID::int32 segment_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2eproto;
};
// -------------------------------------------------------------------

class SLUStarted :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.SLUStarted) */ {
 public:
  SLUStarted();
  virtual ~SLUStarted();

  SLUStarted(const SLUStarted& from);
  SLUStarted(SLUStarted&& from) noexcept
    : SLUStarted() {
    *this = ::std::move(from);
  }

  inline SLUStarted& operator=(const SLUStarted& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUStarted& operator=(SLUStarted&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SLUStarted& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLUStarted* internal_default_instance() {
    return reinterpret_cast<const SLUStarted*>(
               &_SLUStarted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(SLUStarted* other);
  friend void swap(SLUStarted& a, SLUStarted& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLUStarted* New() const final {
    return CreateMaybeMessage<SLUStarted>(nullptr);
  }

  SLUStarted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SLUStarted>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SLUStarted& from);
  void MergeFrom(const SLUStarted& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLUStarted* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.SLUStarted";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_speechly_2eproto);
    return ::descriptor_table_speechly_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string audio_context = 1;
  void clear_audio_context();
  static const int kAudioContextFieldNumber = 1;
  const std::string& audio_context() const;
  void set_audio_context(const std::string& value);
  void set_audio_context(std::string&& value);
  void set_audio_context(const char* value);
  void set_audio_context(const char* value, size_t size);
  std::string* mutable_audio_context();
  std::string* release_audio_context();
  void set_allocated_audio_context(std::string* audio_context);

  // @@protoc_insertion_point(class_scope:v1.SLUStarted)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_context_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2eproto;
};
// -------------------------------------------------------------------

class SLUFinished :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.SLUFinished) */ {
 public:
  SLUFinished();
  virtual ~SLUFinished();

  SLUFinished(const SLUFinished& from);
  SLUFinished(SLUFinished&& from) noexcept
    : SLUFinished() {
    *this = ::std::move(from);
  }

  inline SLUFinished& operator=(const SLUFinished& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUFinished& operator=(SLUFinished&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SLUFinished& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLUFinished* internal_default_instance() {
    return reinterpret_cast<const SLUFinished*>(
               &_SLUFinished_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(SLUFinished* other);
  friend void swap(SLUFinished& a, SLUFinished& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLUFinished* New() const final {
    return CreateMaybeMessage<SLUFinished>(nullptr);
  }

  SLUFinished* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SLUFinished>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SLUFinished& from);
  void MergeFrom(const SLUFinished& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLUFinished* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.SLUFinished";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_speechly_2eproto);
    return ::descriptor_table_speechly_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string audio_context = 1;
  void clear_audio_context();
  static const int kAudioContextFieldNumber = 1;
  const std::string& audio_context() const;
  void set_audio_context(const std::string& value);
  void set_audio_context(std::string&& value);
  void set_audio_context(const char* value);
  void set_audio_context(const char* value, size_t size);
  std::string* mutable_audio_context();
  std::string* release_audio_context();
  void set_allocated_audio_context(std::string* audio_context);

  // .v1.SLUError error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::v1::SLUError& error() const;
  ::v1::SLUError* release_error();
  ::v1::SLUError* mutable_error();
  void set_allocated_error(::v1::SLUError* error);

  // @@protoc_insertion_point(class_scope:v1.SLUFinished)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_context_;
  ::v1::SLUError* error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2eproto;
};
// -------------------------------------------------------------------

class SLUError :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.SLUError) */ {
 public:
  SLUError();
  virtual ~SLUError();

  SLUError(const SLUError& from);
  SLUError(SLUError&& from) noexcept
    : SLUError() {
    *this = ::std::move(from);
  }

  inline SLUError& operator=(const SLUError& from) {
    CopyFrom(from);
    return *this;
  }
  inline SLUError& operator=(SLUError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SLUError& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SLUError* internal_default_instance() {
    return reinterpret_cast<const SLUError*>(
               &_SLUError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(SLUError* other);
  friend void swap(SLUError& a, SLUError& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SLUError* New() const final {
    return CreateMaybeMessage<SLUError>(nullptr);
  }

  SLUError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SLUError>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SLUError& from);
  void MergeFrom(const SLUError& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SLUError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.SLUError";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_speechly_2eproto);
    return ::descriptor_table_speechly_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  const std::string& code() const;
  void set_code(const std::string& value);
  void set_code(std::string&& value);
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  std::string* mutable_code();
  std::string* release_code();
  void set_allocated_code(std::string* code);

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);

  // @@protoc_insertion_point(class_scope:v1.SLUError)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2eproto;
};
// -------------------------------------------------------------------

class WLURequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.WLURequest) */ {
 public:
  WLURequest();
  virtual ~WLURequest();

  WLURequest(const WLURequest& from);
  WLURequest(WLURequest&& from) noexcept
    : WLURequest() {
    *this = ::std::move(from);
  }

  inline WLURequest& operator=(const WLURequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WLURequest& operator=(WLURequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WLURequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WLURequest* internal_default_instance() {
    return reinterpret_cast<const WLURequest*>(
               &_WLURequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(WLURequest* other);
  friend void swap(WLURequest& a, WLURequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WLURequest* New() const final {
    return CreateMaybeMessage<WLURequest>(nullptr);
  }

  WLURequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WLURequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WLURequest& from);
  void MergeFrom(const WLURequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WLURequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.WLURequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_speechly_2eproto);
    return ::descriptor_table_speechly_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string language_code = 1;
  void clear_language_code();
  static const int kLanguageCodeFieldNumber = 1;
  const std::string& language_code() const;
  void set_language_code(const std::string& value);
  void set_language_code(std::string&& value);
  void set_language_code(const char* value);
  void set_language_code(const char* value, size_t size);
  std::string* mutable_language_code();
  std::string* release_language_code();
  void set_allocated_language_code(std::string* language_code);

  // string text = 2;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);

  // @@protoc_insertion_point(class_scope:v1.WLURequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2eproto;
};
// -------------------------------------------------------------------

class WLUResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.WLUResponse) */ {
 public:
  WLUResponse();
  virtual ~WLUResponse();

  WLUResponse(const WLUResponse& from);
  WLUResponse(WLUResponse&& from) noexcept
    : WLUResponse() {
    *this = ::std::move(from);
  }

  inline WLUResponse& operator=(const WLUResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WLUResponse& operator=(WLUResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WLUResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WLUResponse* internal_default_instance() {
    return reinterpret_cast<const WLUResponse*>(
               &_WLUResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(WLUResponse* other);
  friend void swap(WLUResponse& a, WLUResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WLUResponse* New() const final {
    return CreateMaybeMessage<WLUResponse>(nullptr);
  }

  WLUResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WLUResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WLUResponse& from);
  void MergeFrom(const WLUResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WLUResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.WLUResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_speechly_2eproto);
    return ::descriptor_table_speechly_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .v1.SLUResponse responses = 1;
  int responses_size() const;
  void clear_responses();
  static const int kResponsesFieldNumber = 1;
  ::v1::SLUResponse* mutable_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::SLUResponse >*
      mutable_responses();
  const ::v1::SLUResponse& responses(int index) const;
  ::v1::SLUResponse* add_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::SLUResponse >&
      responses() const;

  // @@protoc_insertion_point(class_scope:v1.WLUResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::SLUResponse > responses_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.LoginRequest) */ {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoginRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(LoginRequest* other);
  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const final {
    return CreateMaybeMessage<LoginRequest>(nullptr);
  }

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.LoginRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_speechly_2eproto);
    return ::descriptor_table_speechly_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string device_id = 1;
  void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  const std::string& device_id() const;
  void set_device_id(const std::string& value);
  void set_device_id(std::string&& value);
  void set_device_id(const char* value);
  void set_device_id(const char* value, size_t size);
  std::string* mutable_device_id();
  std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);

  // string app_id = 2;
  void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  const std::string& app_id() const;
  void set_app_id(const std::string& value);
  void set_app_id(std::string&& value);
  void set_app_id(const char* value);
  void set_app_id(const char* value, size_t size);
  std::string* mutable_app_id();
  std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);

  // @@protoc_insertion_point(class_scope:v1.LoginRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.LoginResponse) */ {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoginResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(LoginResponse* other);
  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginResponse* New() const final {
    return CreateMaybeMessage<LoginResponse>(nullptr);
  }

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.LoginResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_speechly_2eproto);
    return ::descriptor_table_speechly_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string token = 1;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);

  // @@protoc_insertion_point(class_scope:v1.LoginResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speechly_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SLURequest

// .v1.SLUConfig config = 1;
inline bool SLURequest::has_config() const {
  return streaming_request_case() == kConfig;
}
inline void SLURequest::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void SLURequest::clear_config() {
  if (has_config()) {
    delete streaming_request_.config_;
    clear_has_streaming_request();
  }
}
inline ::v1::SLUConfig* SLURequest::release_config() {
  // @@protoc_insertion_point(field_release:v1.SLURequest.config)
  if (has_config()) {
    clear_has_streaming_request();
      ::v1::SLUConfig* temp = streaming_request_.config_;
    streaming_request_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::SLUConfig& SLURequest::config() const {
  // @@protoc_insertion_point(field_get:v1.SLURequest.config)
  return has_config()
      ? *streaming_request_.config_
      : *reinterpret_cast< ::v1::SLUConfig*>(&::v1::_SLUConfig_default_instance_);
}
inline ::v1::SLUConfig* SLURequest::mutable_config() {
  if (!has_config()) {
    clear_streaming_request();
    set_has_config();
    streaming_request_.config_ = CreateMaybeMessage< ::v1::SLUConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.SLURequest.config)
  return streaming_request_.config_;
}

// .v1.SLUEvent event = 2;
inline bool SLURequest::has_event() const {
  return streaming_request_case() == kEvent;
}
inline void SLURequest::set_has_event() {
  _oneof_case_[0] = kEvent;
}
inline void SLURequest::clear_event() {
  if (has_event()) {
    delete streaming_request_.event_;
    clear_has_streaming_request();
  }
}
inline ::v1::SLUEvent* SLURequest::release_event() {
  // @@protoc_insertion_point(field_release:v1.SLURequest.event)
  if (has_event()) {
    clear_has_streaming_request();
      ::v1::SLUEvent* temp = streaming_request_.event_;
    streaming_request_.event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::SLUEvent& SLURequest::event() const {
  // @@protoc_insertion_point(field_get:v1.SLURequest.event)
  return has_event()
      ? *streaming_request_.event_
      : *reinterpret_cast< ::v1::SLUEvent*>(&::v1::_SLUEvent_default_instance_);
}
inline ::v1::SLUEvent* SLURequest::mutable_event() {
  if (!has_event()) {
    clear_streaming_request();
    set_has_event();
    streaming_request_.event_ = CreateMaybeMessage< ::v1::SLUEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.SLURequest.event)
  return streaming_request_.event_;
}

// bytes audio = 3;
inline bool SLURequest::has_audio() const {
  return streaming_request_case() == kAudio;
}
inline void SLURequest::set_has_audio() {
  _oneof_case_[0] = kAudio;
}
inline void SLURequest::clear_audio() {
  if (has_audio()) {
    streaming_request_.audio_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_streaming_request();
  }
}
inline const std::string& SLURequest::audio() const {
  // @@protoc_insertion_point(field_get:v1.SLURequest.audio)
  if (has_audio()) {
    return streaming_request_.audio_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SLURequest::set_audio(const std::string& value) {
  // @@protoc_insertion_point(field_set:v1.SLURequest.audio)
  if (!has_audio()) {
    clear_streaming_request();
    set_has_audio();
    streaming_request_.audio_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streaming_request_.audio_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.SLURequest.audio)
}
inline void SLURequest::set_audio(std::string&& value) {
  // @@protoc_insertion_point(field_set:v1.SLURequest.audio)
  if (!has_audio()) {
    clear_streaming_request();
    set_has_audio();
    streaming_request_.audio_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streaming_request_.audio_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.SLURequest.audio)
}
inline void SLURequest::set_audio(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_audio()) {
    clear_streaming_request();
    set_has_audio();
    streaming_request_.audio_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streaming_request_.audio_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.SLURequest.audio)
}
inline void SLURequest::set_audio(const void* value, size_t size) {
  if (!has_audio()) {
    clear_streaming_request();
    set_has_audio();
    streaming_request_.audio_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  streaming_request_.audio_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.SLURequest.audio)
}
inline std::string* SLURequest::mutable_audio() {
  if (!has_audio()) {
    clear_streaming_request();
    set_has_audio();
    streaming_request_.audio_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:v1.SLURequest.audio)
  return streaming_request_.audio_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SLURequest::release_audio() {
  // @@protoc_insertion_point(field_release:v1.SLURequest.audio)
  if (has_audio()) {
    clear_has_streaming_request();
    return streaming_request_.audio_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void SLURequest::set_allocated_audio(std::string* audio) {
  if (has_streaming_request()) {
    clear_streaming_request();
  }
  if (audio != nullptr) {
    set_has_audio();
    streaming_request_.audio_.UnsafeSetDefault(audio);
  }
  // @@protoc_insertion_point(field_set_allocated:v1.SLURequest.audio)
}

inline bool SLURequest::has_streaming_request() const {
  return streaming_request_case() != STREAMING_REQUEST_NOT_SET;
}
inline void SLURequest::clear_has_streaming_request() {
  _oneof_case_[0] = STREAMING_REQUEST_NOT_SET;
}
inline SLURequest::StreamingRequestCase SLURequest::streaming_request_case() const {
  return SLURequest::StreamingRequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SLUConfig

// .v1.SLUConfig.Encoding encoding = 1;
inline void SLUConfig::clear_encoding() {
  encoding_ = 0;
}
inline ::v1::SLUConfig_Encoding SLUConfig::encoding() const {
  // @@protoc_insertion_point(field_get:v1.SLUConfig.encoding)
  return static_cast< ::v1::SLUConfig_Encoding >(encoding_);
}
inline void SLUConfig::set_encoding(::v1::SLUConfig_Encoding value) {
  
  encoding_ = value;
  // @@protoc_insertion_point(field_set:v1.SLUConfig.encoding)
}

// int32 channels = 2;
inline void SLUConfig::clear_channels() {
  channels_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SLUConfig::channels() const {
  // @@protoc_insertion_point(field_get:v1.SLUConfig.channels)
  return channels_;
}
inline void SLUConfig::set_channels(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  channels_ = value;
  // @@protoc_insertion_point(field_set:v1.SLUConfig.channels)
}

// int32 sample_rate_hertz = 3;
inline void SLUConfig::clear_sample_rate_hertz() {
  sample_rate_hertz_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SLUConfig::sample_rate_hertz() const {
  // @@protoc_insertion_point(field_get:v1.SLUConfig.sample_rate_hertz)
  return sample_rate_hertz_;
}
inline void SLUConfig::set_sample_rate_hertz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sample_rate_hertz_ = value;
  // @@protoc_insertion_point(field_set:v1.SLUConfig.sample_rate_hertz)
}

// string language_code = 4;
inline void SLUConfig::clear_language_code() {
  language_code_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SLUConfig::language_code() const {
  // @@protoc_insertion_point(field_get:v1.SLUConfig.language_code)
  return language_code_.GetNoArena();
}
inline void SLUConfig::set_language_code(const std::string& value) {
  
  language_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.SLUConfig.language_code)
}
inline void SLUConfig::set_language_code(std::string&& value) {
  
  language_code_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.SLUConfig.language_code)
}
inline void SLUConfig::set_language_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  language_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.SLUConfig.language_code)
}
inline void SLUConfig::set_language_code(const char* value, size_t size) {
  
  language_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.SLUConfig.language_code)
}
inline std::string* SLUConfig::mutable_language_code() {
  
  // @@protoc_insertion_point(field_mutable:v1.SLUConfig.language_code)
  return language_code_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SLUConfig::release_language_code() {
  // @@protoc_insertion_point(field_release:v1.SLUConfig.language_code)
  
  return language_code_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SLUConfig::set_allocated_language_code(std::string* language_code) {
  if (language_code != nullptr) {
    
  } else {
    
  }
  language_code_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language_code);
  // @@protoc_insertion_point(field_set_allocated:v1.SLUConfig.language_code)
}

// -------------------------------------------------------------------

// SLUEvent

// .v1.SLUEvent.Event event = 1;
inline void SLUEvent::clear_event() {
  event_ = 0;
}
inline ::v1::SLUEvent_Event SLUEvent::event() const {
  // @@protoc_insertion_point(field_get:v1.SLUEvent.event)
  return static_cast< ::v1::SLUEvent_Event >(event_);
}
inline void SLUEvent::set_event(::v1::SLUEvent_Event value) {
  
  event_ = value;
  // @@protoc_insertion_point(field_set:v1.SLUEvent.event)
}

// -------------------------------------------------------------------

// SLUResponse

// .v1.TranscriptEvent transcript = 1;
inline bool SLUResponse::has_transcript() const {
  return streaming_response_case() == kTranscript;
}
inline void SLUResponse::set_has_transcript() {
  _oneof_case_[0] = kTranscript;
}
inline void SLUResponse::clear_transcript() {
  if (has_transcript()) {
    delete streaming_response_.transcript_;
    clear_has_streaming_response();
  }
}
inline ::v1::TranscriptEvent* SLUResponse::release_transcript() {
  // @@protoc_insertion_point(field_release:v1.SLUResponse.transcript)
  if (has_transcript()) {
    clear_has_streaming_response();
      ::v1::TranscriptEvent* temp = streaming_response_.transcript_;
    streaming_response_.transcript_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::TranscriptEvent& SLUResponse::transcript() const {
  // @@protoc_insertion_point(field_get:v1.SLUResponse.transcript)
  return has_transcript()
      ? *streaming_response_.transcript_
      : *reinterpret_cast< ::v1::TranscriptEvent*>(&::v1::_TranscriptEvent_default_instance_);
}
inline ::v1::TranscriptEvent* SLUResponse::mutable_transcript() {
  if (!has_transcript()) {
    clear_streaming_response();
    set_has_transcript();
    streaming_response_.transcript_ = CreateMaybeMessage< ::v1::TranscriptEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.SLUResponse.transcript)
  return streaming_response_.transcript_;
}

// .v1.EntityEvent entity = 2;
inline bool SLUResponse::has_entity() const {
  return streaming_response_case() == kEntity;
}
inline void SLUResponse::set_has_entity() {
  _oneof_case_[0] = kEntity;
}
inline void SLUResponse::clear_entity() {
  if (has_entity()) {
    delete streaming_response_.entity_;
    clear_has_streaming_response();
  }
}
inline ::v1::EntityEvent* SLUResponse::release_entity() {
  // @@protoc_insertion_point(field_release:v1.SLUResponse.entity)
  if (has_entity()) {
    clear_has_streaming_response();
      ::v1::EntityEvent* temp = streaming_response_.entity_;
    streaming_response_.entity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::EntityEvent& SLUResponse::entity() const {
  // @@protoc_insertion_point(field_get:v1.SLUResponse.entity)
  return has_entity()
      ? *streaming_response_.entity_
      : *reinterpret_cast< ::v1::EntityEvent*>(&::v1::_EntityEvent_default_instance_);
}
inline ::v1::EntityEvent* SLUResponse::mutable_entity() {
  if (!has_entity()) {
    clear_streaming_response();
    set_has_entity();
    streaming_response_.entity_ = CreateMaybeMessage< ::v1::EntityEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.SLUResponse.entity)
  return streaming_response_.entity_;
}

// .v1.IntentEvent intent = 3;
inline bool SLUResponse::has_intent() const {
  return streaming_response_case() == kIntent;
}
inline void SLUResponse::set_has_intent() {
  _oneof_case_[0] = kIntent;
}
inline void SLUResponse::clear_intent() {
  if (has_intent()) {
    delete streaming_response_.intent_;
    clear_has_streaming_response();
  }
}
inline ::v1::IntentEvent* SLUResponse::release_intent() {
  // @@protoc_insertion_point(field_release:v1.SLUResponse.intent)
  if (has_intent()) {
    clear_has_streaming_response();
      ::v1::IntentEvent* temp = streaming_response_.intent_;
    streaming_response_.intent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::IntentEvent& SLUResponse::intent() const {
  // @@protoc_insertion_point(field_get:v1.SLUResponse.intent)
  return has_intent()
      ? *streaming_response_.intent_
      : *reinterpret_cast< ::v1::IntentEvent*>(&::v1::_IntentEvent_default_instance_);
}
inline ::v1::IntentEvent* SLUResponse::mutable_intent() {
  if (!has_intent()) {
    clear_streaming_response();
    set_has_intent();
    streaming_response_.intent_ = CreateMaybeMessage< ::v1::IntentEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.SLUResponse.intent)
  return streaming_response_.intent_;
}

// .v1.SegmentEndEvent segment_end = 4;
inline bool SLUResponse::has_segment_end() const {
  return streaming_response_case() == kSegmentEnd;
}
inline void SLUResponse::set_has_segment_end() {
  _oneof_case_[0] = kSegmentEnd;
}
inline void SLUResponse::clear_segment_end() {
  if (has_segment_end()) {
    delete streaming_response_.segment_end_;
    clear_has_streaming_response();
  }
}
inline ::v1::SegmentEndEvent* SLUResponse::release_segment_end() {
  // @@protoc_insertion_point(field_release:v1.SLUResponse.segment_end)
  if (has_segment_end()) {
    clear_has_streaming_response();
      ::v1::SegmentEndEvent* temp = streaming_response_.segment_end_;
    streaming_response_.segment_end_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::SegmentEndEvent& SLUResponse::segment_end() const {
  // @@protoc_insertion_point(field_get:v1.SLUResponse.segment_end)
  return has_segment_end()
      ? *streaming_response_.segment_end_
      : *reinterpret_cast< ::v1::SegmentEndEvent*>(&::v1::_SegmentEndEvent_default_instance_);
}
inline ::v1::SegmentEndEvent* SLUResponse::mutable_segment_end() {
  if (!has_segment_end()) {
    clear_streaming_response();
    set_has_segment_end();
    streaming_response_.segment_end_ = CreateMaybeMessage< ::v1::SegmentEndEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.SLUResponse.segment_end)
  return streaming_response_.segment_end_;
}

// .v1.TentativeTranscriptEvent tentative_transcript = 5;
inline bool SLUResponse::has_tentative_transcript() const {
  return streaming_response_case() == kTentativeTranscript;
}
inline void SLUResponse::set_has_tentative_transcript() {
  _oneof_case_[0] = kTentativeTranscript;
}
inline void SLUResponse::clear_tentative_transcript() {
  if (has_tentative_transcript()) {
    delete streaming_response_.tentative_transcript_;
    clear_has_streaming_response();
  }
}
inline ::v1::TentativeTranscriptEvent* SLUResponse::release_tentative_transcript() {
  // @@protoc_insertion_point(field_release:v1.SLUResponse.tentative_transcript)
  if (has_tentative_transcript()) {
    clear_has_streaming_response();
      ::v1::TentativeTranscriptEvent* temp = streaming_response_.tentative_transcript_;
    streaming_response_.tentative_transcript_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::TentativeTranscriptEvent& SLUResponse::tentative_transcript() const {
  // @@protoc_insertion_point(field_get:v1.SLUResponse.tentative_transcript)
  return has_tentative_transcript()
      ? *streaming_response_.tentative_transcript_
      : *reinterpret_cast< ::v1::TentativeTranscriptEvent*>(&::v1::_TentativeTranscriptEvent_default_instance_);
}
inline ::v1::TentativeTranscriptEvent* SLUResponse::mutable_tentative_transcript() {
  if (!has_tentative_transcript()) {
    clear_streaming_response();
    set_has_tentative_transcript();
    streaming_response_.tentative_transcript_ = CreateMaybeMessage< ::v1::TentativeTranscriptEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.SLUResponse.tentative_transcript)
  return streaming_response_.tentative_transcript_;
}

// .v1.TentativeEntitiesEvent tentative_entities = 6;
inline bool SLUResponse::has_tentative_entities() const {
  return streaming_response_case() == kTentativeEntities;
}
inline void SLUResponse::set_has_tentative_entities() {
  _oneof_case_[0] = kTentativeEntities;
}
inline void SLUResponse::clear_tentative_entities() {
  if (has_tentative_entities()) {
    delete streaming_response_.tentative_entities_;
    clear_has_streaming_response();
  }
}
inline ::v1::TentativeEntitiesEvent* SLUResponse::release_tentative_entities() {
  // @@protoc_insertion_point(field_release:v1.SLUResponse.tentative_entities)
  if (has_tentative_entities()) {
    clear_has_streaming_response();
      ::v1::TentativeEntitiesEvent* temp = streaming_response_.tentative_entities_;
    streaming_response_.tentative_entities_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::TentativeEntitiesEvent& SLUResponse::tentative_entities() const {
  // @@protoc_insertion_point(field_get:v1.SLUResponse.tentative_entities)
  return has_tentative_entities()
      ? *streaming_response_.tentative_entities_
      : *reinterpret_cast< ::v1::TentativeEntitiesEvent*>(&::v1::_TentativeEntitiesEvent_default_instance_);
}
inline ::v1::TentativeEntitiesEvent* SLUResponse::mutable_tentative_entities() {
  if (!has_tentative_entities()) {
    clear_streaming_response();
    set_has_tentative_entities();
    streaming_response_.tentative_entities_ = CreateMaybeMessage< ::v1::TentativeEntitiesEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.SLUResponse.tentative_entities)
  return streaming_response_.tentative_entities_;
}

// .v1.IntentEvent tentative_intent = 7;
inline bool SLUResponse::has_tentative_intent() const {
  return streaming_response_case() == kTentativeIntent;
}
inline void SLUResponse::set_has_tentative_intent() {
  _oneof_case_[0] = kTentativeIntent;
}
inline void SLUResponse::clear_tentative_intent() {
  if (has_tentative_intent()) {
    delete streaming_response_.tentative_intent_;
    clear_has_streaming_response();
  }
}
inline ::v1::IntentEvent* SLUResponse::release_tentative_intent() {
  // @@protoc_insertion_point(field_release:v1.SLUResponse.tentative_intent)
  if (has_tentative_intent()) {
    clear_has_streaming_response();
      ::v1::IntentEvent* temp = streaming_response_.tentative_intent_;
    streaming_response_.tentative_intent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::IntentEvent& SLUResponse::tentative_intent() const {
  // @@protoc_insertion_point(field_get:v1.SLUResponse.tentative_intent)
  return has_tentative_intent()
      ? *streaming_response_.tentative_intent_
      : *reinterpret_cast< ::v1::IntentEvent*>(&::v1::_IntentEvent_default_instance_);
}
inline ::v1::IntentEvent* SLUResponse::mutable_tentative_intent() {
  if (!has_tentative_intent()) {
    clear_streaming_response();
    set_has_tentative_intent();
    streaming_response_.tentative_intent_ = CreateMaybeMessage< ::v1::IntentEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.SLUResponse.tentative_intent)
  return streaming_response_.tentative_intent_;
}

// .v1.SLUStarted started = 8;
inline bool SLUResponse::has_started() const {
  return streaming_response_case() == kStarted;
}
inline void SLUResponse::set_has_started() {
  _oneof_case_[0] = kStarted;
}
inline void SLUResponse::clear_started() {
  if (has_started()) {
    delete streaming_response_.started_;
    clear_has_streaming_response();
  }
}
inline ::v1::SLUStarted* SLUResponse::release_started() {
  // @@protoc_insertion_point(field_release:v1.SLUResponse.started)
  if (has_started()) {
    clear_has_streaming_response();
      ::v1::SLUStarted* temp = streaming_response_.started_;
    streaming_response_.started_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::SLUStarted& SLUResponse::started() const {
  // @@protoc_insertion_point(field_get:v1.SLUResponse.started)
  return has_started()
      ? *streaming_response_.started_
      : *reinterpret_cast< ::v1::SLUStarted*>(&::v1::_SLUStarted_default_instance_);
}
inline ::v1::SLUStarted* SLUResponse::mutable_started() {
  if (!has_started()) {
    clear_streaming_response();
    set_has_started();
    streaming_response_.started_ = CreateMaybeMessage< ::v1::SLUStarted >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.SLUResponse.started)
  return streaming_response_.started_;
}

// .v1.SLUFinished finished = 9;
inline bool SLUResponse::has_finished() const {
  return streaming_response_case() == kFinished;
}
inline void SLUResponse::set_has_finished() {
  _oneof_case_[0] = kFinished;
}
inline void SLUResponse::clear_finished() {
  if (has_finished()) {
    delete streaming_response_.finished_;
    clear_has_streaming_response();
  }
}
inline ::v1::SLUFinished* SLUResponse::release_finished() {
  // @@protoc_insertion_point(field_release:v1.SLUResponse.finished)
  if (has_finished()) {
    clear_has_streaming_response();
      ::v1::SLUFinished* temp = streaming_response_.finished_;
    streaming_response_.finished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::SLUFinished& SLUResponse::finished() const {
  // @@protoc_insertion_point(field_get:v1.SLUResponse.finished)
  return has_finished()
      ? *streaming_response_.finished_
      : *reinterpret_cast< ::v1::SLUFinished*>(&::v1::_SLUFinished_default_instance_);
}
inline ::v1::SLUFinished* SLUResponse::mutable_finished() {
  if (!has_finished()) {
    clear_streaming_response();
    set_has_finished();
    streaming_response_.finished_ = CreateMaybeMessage< ::v1::SLUFinished >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:v1.SLUResponse.finished)
  return streaming_response_.finished_;
}

inline bool SLUResponse::has_streaming_response() const {
  return streaming_response_case() != STREAMING_RESPONSE_NOT_SET;
}
inline void SLUResponse::clear_has_streaming_response() {
  _oneof_case_[0] = STREAMING_RESPONSE_NOT_SET;
}
inline SLUResponse::StreamingResponseCase SLUResponse::streaming_response_case() const {
  return SLUResponse::StreamingResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TentativeTranscriptEvent

// string tentative_transcript = 1;
inline void TentativeTranscriptEvent::clear_tentative_transcript() {
  tentative_transcript_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TentativeTranscriptEvent::tentative_transcript() const {
  // @@protoc_insertion_point(field_get:v1.TentativeTranscriptEvent.tentative_transcript)
  return tentative_transcript_.GetNoArena();
}
inline void TentativeTranscriptEvent::set_tentative_transcript(const std::string& value) {
  
  tentative_transcript_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.TentativeTranscriptEvent.tentative_transcript)
}
inline void TentativeTranscriptEvent::set_tentative_transcript(std::string&& value) {
  
  tentative_transcript_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.TentativeTranscriptEvent.tentative_transcript)
}
inline void TentativeTranscriptEvent::set_tentative_transcript(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tentative_transcript_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.TentativeTranscriptEvent.tentative_transcript)
}
inline void TentativeTranscriptEvent::set_tentative_transcript(const char* value, size_t size) {
  
  tentative_transcript_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.TentativeTranscriptEvent.tentative_transcript)
}
inline std::string* TentativeTranscriptEvent::mutable_tentative_transcript() {
  
  // @@protoc_insertion_point(field_mutable:v1.TentativeTranscriptEvent.tentative_transcript)
  return tentative_transcript_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TentativeTranscriptEvent::release_tentative_transcript() {
  // @@protoc_insertion_point(field_release:v1.TentativeTranscriptEvent.tentative_transcript)
  
  return tentative_transcript_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TentativeTranscriptEvent::set_allocated_tentative_transcript(std::string* tentative_transcript) {
  if (tentative_transcript != nullptr) {
    
  } else {
    
  }
  tentative_transcript_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tentative_transcript);
  // @@protoc_insertion_point(field_set_allocated:v1.TentativeTranscriptEvent.tentative_transcript)
}

// repeated .v1.TranscriptEvent tentative_words = 2;
inline int TentativeTranscriptEvent::tentative_words_size() const {
  return tentative_words_.size();
}
inline void TentativeTranscriptEvent::clear_tentative_words() {
  tentative_words_.Clear();
}
inline ::v1::TranscriptEvent* TentativeTranscriptEvent::mutable_tentative_words(int index) {
  // @@protoc_insertion_point(field_mutable:v1.TentativeTranscriptEvent.tentative_words)
  return tentative_words_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::TranscriptEvent >*
TentativeTranscriptEvent::mutable_tentative_words() {
  // @@protoc_insertion_point(field_mutable_list:v1.TentativeTranscriptEvent.tentative_words)
  return &tentative_words_;
}
inline const ::v1::TranscriptEvent& TentativeTranscriptEvent::tentative_words(int index) const {
  // @@protoc_insertion_point(field_get:v1.TentativeTranscriptEvent.tentative_words)
  return tentative_words_.Get(index);
}
inline ::v1::TranscriptEvent* TentativeTranscriptEvent::add_tentative_words() {
  // @@protoc_insertion_point(field_add:v1.TentativeTranscriptEvent.tentative_words)
  return tentative_words_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::TranscriptEvent >&
TentativeTranscriptEvent::tentative_words() const {
  // @@protoc_insertion_point(field_list:v1.TentativeTranscriptEvent.tentative_words)
  return tentative_words_;
}

// -------------------------------------------------------------------

// TranscriptEvent

// string audio_context = 1;
inline void TranscriptEvent::clear_audio_context() {
  audio_context_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TranscriptEvent::audio_context() const {
  // @@protoc_insertion_point(field_get:v1.TranscriptEvent.audio_context)
  return audio_context_.GetNoArena();
}
inline void TranscriptEvent::set_audio_context(const std::string& value) {
  
  audio_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.TranscriptEvent.audio_context)
}
inline void TranscriptEvent::set_audio_context(std::string&& value) {
  
  audio_context_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.TranscriptEvent.audio_context)
}
inline void TranscriptEvent::set_audio_context(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  audio_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.TranscriptEvent.audio_context)
}
inline void TranscriptEvent::set_audio_context(const char* value, size_t size) {
  
  audio_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.TranscriptEvent.audio_context)
}
inline std::string* TranscriptEvent::mutable_audio_context() {
  
  // @@protoc_insertion_point(field_mutable:v1.TranscriptEvent.audio_context)
  return audio_context_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TranscriptEvent::release_audio_context() {
  // @@protoc_insertion_point(field_release:v1.TranscriptEvent.audio_context)
  
  return audio_context_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TranscriptEvent::set_allocated_audio_context(std::string* audio_context) {
  if (audio_context != nullptr) {
    
  } else {
    
  }
  audio_context_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), audio_context);
  // @@protoc_insertion_point(field_set_allocated:v1.TranscriptEvent.audio_context)
}

// int32 segment_id = 2;
inline void TranscriptEvent::clear_segment_id() {
  segment_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TranscriptEvent::segment_id() const {
  // @@protoc_insertion_point(field_get:v1.TranscriptEvent.segment_id)
  return segment_id_;
}
inline void TranscriptEvent::set_segment_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  segment_id_ = value;
  // @@protoc_insertion_point(field_set:v1.TranscriptEvent.segment_id)
}

// string word = 3;
inline void TranscriptEvent::clear_word() {
  word_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TranscriptEvent::word() const {
  // @@protoc_insertion_point(field_get:v1.TranscriptEvent.word)
  return word_.GetNoArena();
}
inline void TranscriptEvent::set_word(const std::string& value) {
  
  word_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.TranscriptEvent.word)
}
inline void TranscriptEvent::set_word(std::string&& value) {
  
  word_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.TranscriptEvent.word)
}
inline void TranscriptEvent::set_word(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  word_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.TranscriptEvent.word)
}
inline void TranscriptEvent::set_word(const char* value, size_t size) {
  
  word_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.TranscriptEvent.word)
}
inline std::string* TranscriptEvent::mutable_word() {
  
  // @@protoc_insertion_point(field_mutable:v1.TranscriptEvent.word)
  return word_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TranscriptEvent::release_word() {
  // @@protoc_insertion_point(field_release:v1.TranscriptEvent.word)
  
  return word_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TranscriptEvent::set_allocated_word(std::string* word) {
  if (word != nullptr) {
    
  } else {
    
  }
  word_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), word);
  // @@protoc_insertion_point(field_set_allocated:v1.TranscriptEvent.word)
}

// int32 index = 4;
inline void TranscriptEvent::clear_index() {
  index_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TranscriptEvent::index() const {
  // @@protoc_insertion_point(field_get:v1.TranscriptEvent.index)
  return index_;
}
inline void TranscriptEvent::set_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:v1.TranscriptEvent.index)
}

// int32 start_time = 5;
inline void TranscriptEvent::clear_start_time() {
  start_time_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TranscriptEvent::start_time() const {
  // @@protoc_insertion_point(field_get:v1.TranscriptEvent.start_time)
  return start_time_;
}
inline void TranscriptEvent::set_start_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_time_ = value;
  // @@protoc_insertion_point(field_set:v1.TranscriptEvent.start_time)
}

// int32 end_time = 6;
inline void TranscriptEvent::clear_end_time() {
  end_time_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TranscriptEvent::end_time() const {
  // @@protoc_insertion_point(field_get:v1.TranscriptEvent.end_time)
  return end_time_;
}
inline void TranscriptEvent::set_end_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_time_ = value;
  // @@protoc_insertion_point(field_set:v1.TranscriptEvent.end_time)
}

// -------------------------------------------------------------------

// TentativeEntitiesEvent

// repeated .v1.EntityEvent tentative_entities = 1;
inline int TentativeEntitiesEvent::tentative_entities_size() const {
  return tentative_entities_.size();
}
inline void TentativeEntitiesEvent::clear_tentative_entities() {
  tentative_entities_.Clear();
}
inline ::v1::EntityEvent* TentativeEntitiesEvent::mutable_tentative_entities(int index) {
  // @@protoc_insertion_point(field_mutable:v1.TentativeEntitiesEvent.tentative_entities)
  return tentative_entities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::EntityEvent >*
TentativeEntitiesEvent::mutable_tentative_entities() {
  // @@protoc_insertion_point(field_mutable_list:v1.TentativeEntitiesEvent.tentative_entities)
  return &tentative_entities_;
}
inline const ::v1::EntityEvent& TentativeEntitiesEvent::tentative_entities(int index) const {
  // @@protoc_insertion_point(field_get:v1.TentativeEntitiesEvent.tentative_entities)
  return tentative_entities_.Get(index);
}
inline ::v1::EntityEvent* TentativeEntitiesEvent::add_tentative_entities() {
  // @@protoc_insertion_point(field_add:v1.TentativeEntitiesEvent.tentative_entities)
  return tentative_entities_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::EntityEvent >&
TentativeEntitiesEvent::tentative_entities() const {
  // @@protoc_insertion_point(field_list:v1.TentativeEntitiesEvent.tentative_entities)
  return tentative_entities_;
}

// -------------------------------------------------------------------

// EntityEvent

// string audio_context = 1;
inline void EntityEvent::clear_audio_context() {
  audio_context_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& EntityEvent::audio_context() const {
  // @@protoc_insertion_point(field_get:v1.EntityEvent.audio_context)
  return audio_context_.GetNoArena();
}
inline void EntityEvent::set_audio_context(const std::string& value) {
  
  audio_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.EntityEvent.audio_context)
}
inline void EntityEvent::set_audio_context(std::string&& value) {
  
  audio_context_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.EntityEvent.audio_context)
}
inline void EntityEvent::set_audio_context(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  audio_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.EntityEvent.audio_context)
}
inline void EntityEvent::set_audio_context(const char* value, size_t size) {
  
  audio_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.EntityEvent.audio_context)
}
inline std::string* EntityEvent::mutable_audio_context() {
  
  // @@protoc_insertion_point(field_mutable:v1.EntityEvent.audio_context)
  return audio_context_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EntityEvent::release_audio_context() {
  // @@protoc_insertion_point(field_release:v1.EntityEvent.audio_context)
  
  return audio_context_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EntityEvent::set_allocated_audio_context(std::string* audio_context) {
  if (audio_context != nullptr) {
    
  } else {
    
  }
  audio_context_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), audio_context);
  // @@protoc_insertion_point(field_set_allocated:v1.EntityEvent.audio_context)
}

// int32 segment_id = 2;
inline void EntityEvent::clear_segment_id() {
  segment_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EntityEvent::segment_id() const {
  // @@protoc_insertion_point(field_get:v1.EntityEvent.segment_id)
  return segment_id_;
}
inline void EntityEvent::set_segment_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  segment_id_ = value;
  // @@protoc_insertion_point(field_set:v1.EntityEvent.segment_id)
}

// string entity = 3;
inline void EntityEvent::clear_entity() {
  entity_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& EntityEvent::entity() const {
  // @@protoc_insertion_point(field_get:v1.EntityEvent.entity)
  return entity_.GetNoArena();
}
inline void EntityEvent::set_entity(const std::string& value) {
  
  entity_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.EntityEvent.entity)
}
inline void EntityEvent::set_entity(std::string&& value) {
  
  entity_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.EntityEvent.entity)
}
inline void EntityEvent::set_entity(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  entity_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.EntityEvent.entity)
}
inline void EntityEvent::set_entity(const char* value, size_t size) {
  
  entity_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.EntityEvent.entity)
}
inline std::string* EntityEvent::mutable_entity() {
  
  // @@protoc_insertion_point(field_mutable:v1.EntityEvent.entity)
  return entity_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EntityEvent::release_entity() {
  // @@protoc_insertion_point(field_release:v1.EntityEvent.entity)
  
  return entity_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EntityEvent::set_allocated_entity(std::string* entity) {
  if (entity != nullptr) {
    
  } else {
    
  }
  entity_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entity);
  // @@protoc_insertion_point(field_set_allocated:v1.EntityEvent.entity)
}

// string value = 4;
inline void EntityEvent::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& EntityEvent::value() const {
  // @@protoc_insertion_point(field_get:v1.EntityEvent.value)
  return value_.GetNoArena();
}
inline void EntityEvent::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.EntityEvent.value)
}
inline void EntityEvent::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.EntityEvent.value)
}
inline void EntityEvent::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.EntityEvent.value)
}
inline void EntityEvent::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.EntityEvent.value)
}
inline std::string* EntityEvent::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:v1.EntityEvent.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EntityEvent::release_value() {
  // @@protoc_insertion_point(field_release:v1.EntityEvent.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EntityEvent::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:v1.EntityEvent.value)
}

// int32 start_position = 5;
inline void EntityEvent::clear_start_position() {
  start_position_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EntityEvent::start_position() const {
  // @@protoc_insertion_point(field_get:v1.EntityEvent.start_position)
  return start_position_;
}
inline void EntityEvent::set_start_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_position_ = value;
  // @@protoc_insertion_point(field_set:v1.EntityEvent.start_position)
}

// int32 end_position = 6;
inline void EntityEvent::clear_end_position() {
  end_position_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EntityEvent::end_position() const {
  // @@protoc_insertion_point(field_get:v1.EntityEvent.end_position)
  return end_position_;
}
inline void EntityEvent::set_end_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_position_ = value;
  // @@protoc_insertion_point(field_set:v1.EntityEvent.end_position)
}

// -------------------------------------------------------------------

// IntentEvent

// string audio_context = 1;
inline void IntentEvent::clear_audio_context() {
  audio_context_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& IntentEvent::audio_context() const {
  // @@protoc_insertion_point(field_get:v1.IntentEvent.audio_context)
  return audio_context_.GetNoArena();
}
inline void IntentEvent::set_audio_context(const std::string& value) {
  
  audio_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.IntentEvent.audio_context)
}
inline void IntentEvent::set_audio_context(std::string&& value) {
  
  audio_context_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.IntentEvent.audio_context)
}
inline void IntentEvent::set_audio_context(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  audio_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.IntentEvent.audio_context)
}
inline void IntentEvent::set_audio_context(const char* value, size_t size) {
  
  audio_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.IntentEvent.audio_context)
}
inline std::string* IntentEvent::mutable_audio_context() {
  
  // @@protoc_insertion_point(field_mutable:v1.IntentEvent.audio_context)
  return audio_context_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IntentEvent::release_audio_context() {
  // @@protoc_insertion_point(field_release:v1.IntentEvent.audio_context)
  
  return audio_context_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IntentEvent::set_allocated_audio_context(std::string* audio_context) {
  if (audio_context != nullptr) {
    
  } else {
    
  }
  audio_context_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), audio_context);
  // @@protoc_insertion_point(field_set_allocated:v1.IntentEvent.audio_context)
}

// int32 segment_id = 2;
inline void IntentEvent::clear_segment_id() {
  segment_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IntentEvent::segment_id() const {
  // @@protoc_insertion_point(field_get:v1.IntentEvent.segment_id)
  return segment_id_;
}
inline void IntentEvent::set_segment_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  segment_id_ = value;
  // @@protoc_insertion_point(field_set:v1.IntentEvent.segment_id)
}

// string intent = 3;
inline void IntentEvent::clear_intent() {
  intent_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& IntentEvent::intent() const {
  // @@protoc_insertion_point(field_get:v1.IntentEvent.intent)
  return intent_.GetNoArena();
}
inline void IntentEvent::set_intent(const std::string& value) {
  
  intent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.IntentEvent.intent)
}
inline void IntentEvent::set_intent(std::string&& value) {
  
  intent_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.IntentEvent.intent)
}
inline void IntentEvent::set_intent(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  intent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.IntentEvent.intent)
}
inline void IntentEvent::set_intent(const char* value, size_t size) {
  
  intent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.IntentEvent.intent)
}
inline std::string* IntentEvent::mutable_intent() {
  
  // @@protoc_insertion_point(field_mutable:v1.IntentEvent.intent)
  return intent_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IntentEvent::release_intent() {
  // @@protoc_insertion_point(field_release:v1.IntentEvent.intent)
  
  return intent_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IntentEvent::set_allocated_intent(std::string* intent) {
  if (intent != nullptr) {
    
  } else {
    
  }
  intent_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), intent);
  // @@protoc_insertion_point(field_set_allocated:v1.IntentEvent.intent)
}

// -------------------------------------------------------------------

// SegmentEndEvent

// string audio_context = 1;
inline void SegmentEndEvent::clear_audio_context() {
  audio_context_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SegmentEndEvent::audio_context() const {
  // @@protoc_insertion_point(field_get:v1.SegmentEndEvent.audio_context)
  return audio_context_.GetNoArena();
}
inline void SegmentEndEvent::set_audio_context(const std::string& value) {
  
  audio_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.SegmentEndEvent.audio_context)
}
inline void SegmentEndEvent::set_audio_context(std::string&& value) {
  
  audio_context_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.SegmentEndEvent.audio_context)
}
inline void SegmentEndEvent::set_audio_context(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  audio_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.SegmentEndEvent.audio_context)
}
inline void SegmentEndEvent::set_audio_context(const char* value, size_t size) {
  
  audio_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.SegmentEndEvent.audio_context)
}
inline std::string* SegmentEndEvent::mutable_audio_context() {
  
  // @@protoc_insertion_point(field_mutable:v1.SegmentEndEvent.audio_context)
  return audio_context_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SegmentEndEvent::release_audio_context() {
  // @@protoc_insertion_point(field_release:v1.SegmentEndEvent.audio_context)
  
  return audio_context_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SegmentEndEvent::set_allocated_audio_context(std::string* audio_context) {
  if (audio_context != nullptr) {
    
  } else {
    
  }
  audio_context_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), audio_context);
  // @@protoc_insertion_point(field_set_allocated:v1.SegmentEndEvent.audio_context)
}

// int32 segment_id = 2;
inline void SegmentEndEvent::clear_segment_id() {
  segment_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SegmentEndEvent::segment_id() const {
  // @@protoc_insertion_point(field_get:v1.SegmentEndEvent.segment_id)
  return segment_id_;
}
inline void SegmentEndEvent::set_segment_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  segment_id_ = value;
  // @@protoc_insertion_point(field_set:v1.SegmentEndEvent.segment_id)
}

// -------------------------------------------------------------------

// SLUStarted

// string audio_context = 1;
inline void SLUStarted::clear_audio_context() {
  audio_context_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SLUStarted::audio_context() const {
  // @@protoc_insertion_point(field_get:v1.SLUStarted.audio_context)
  return audio_context_.GetNoArena();
}
inline void SLUStarted::set_audio_context(const std::string& value) {
  
  audio_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.SLUStarted.audio_context)
}
inline void SLUStarted::set_audio_context(std::string&& value) {
  
  audio_context_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.SLUStarted.audio_context)
}
inline void SLUStarted::set_audio_context(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  audio_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.SLUStarted.audio_context)
}
inline void SLUStarted::set_audio_context(const char* value, size_t size) {
  
  audio_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.SLUStarted.audio_context)
}
inline std::string* SLUStarted::mutable_audio_context() {
  
  // @@protoc_insertion_point(field_mutable:v1.SLUStarted.audio_context)
  return audio_context_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SLUStarted::release_audio_context() {
  // @@protoc_insertion_point(field_release:v1.SLUStarted.audio_context)
  
  return audio_context_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SLUStarted::set_allocated_audio_context(std::string* audio_context) {
  if (audio_context != nullptr) {
    
  } else {
    
  }
  audio_context_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), audio_context);
  // @@protoc_insertion_point(field_set_allocated:v1.SLUStarted.audio_context)
}

// -------------------------------------------------------------------

// SLUFinished

// string audio_context = 1;
inline void SLUFinished::clear_audio_context() {
  audio_context_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SLUFinished::audio_context() const {
  // @@protoc_insertion_point(field_get:v1.SLUFinished.audio_context)
  return audio_context_.GetNoArena();
}
inline void SLUFinished::set_audio_context(const std::string& value) {
  
  audio_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.SLUFinished.audio_context)
}
inline void SLUFinished::set_audio_context(std::string&& value) {
  
  audio_context_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.SLUFinished.audio_context)
}
inline void SLUFinished::set_audio_context(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  audio_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.SLUFinished.audio_context)
}
inline void SLUFinished::set_audio_context(const char* value, size_t size) {
  
  audio_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.SLUFinished.audio_context)
}
inline std::string* SLUFinished::mutable_audio_context() {
  
  // @@protoc_insertion_point(field_mutable:v1.SLUFinished.audio_context)
  return audio_context_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SLUFinished::release_audio_context() {
  // @@protoc_insertion_point(field_release:v1.SLUFinished.audio_context)
  
  return audio_context_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SLUFinished::set_allocated_audio_context(std::string* audio_context) {
  if (audio_context != nullptr) {
    
  } else {
    
  }
  audio_context_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), audio_context);
  // @@protoc_insertion_point(field_set_allocated:v1.SLUFinished.audio_context)
}

// .v1.SLUError error = 2;
inline bool SLUFinished::has_error() const {
  return this != internal_default_instance() && error_ != nullptr;
}
inline void SLUFinished::clear_error() {
  if (GetArenaNoVirtual() == nullptr && error_ != nullptr) {
    delete error_;
  }
  error_ = nullptr;
}
inline const ::v1::SLUError& SLUFinished::error() const {
  const ::v1::SLUError* p = error_;
  // @@protoc_insertion_point(field_get:v1.SLUFinished.error)
  return p != nullptr ? *p : *reinterpret_cast<const ::v1::SLUError*>(
      &::v1::_SLUError_default_instance_);
}
inline ::v1::SLUError* SLUFinished::release_error() {
  // @@protoc_insertion_point(field_release:v1.SLUFinished.error)
  
  ::v1::SLUError* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::v1::SLUError* SLUFinished::mutable_error() {
  
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::SLUError>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:v1.SLUFinished.error)
  return error_;
}
inline void SLUFinished::set_allocated_error(::v1::SLUError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:v1.SLUFinished.error)
}

// -------------------------------------------------------------------

// SLUError

// string code = 1;
inline void SLUError::clear_code() {
  code_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SLUError::code() const {
  // @@protoc_insertion_point(field_get:v1.SLUError.code)
  return code_.GetNoArena();
}
inline void SLUError::set_code(const std::string& value) {
  
  code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.SLUError.code)
}
inline void SLUError::set_code(std::string&& value) {
  
  code_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.SLUError.code)
}
inline void SLUError::set_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.SLUError.code)
}
inline void SLUError::set_code(const char* value, size_t size) {
  
  code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.SLUError.code)
}
inline std::string* SLUError::mutable_code() {
  
  // @@protoc_insertion_point(field_mutable:v1.SLUError.code)
  return code_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SLUError::release_code() {
  // @@protoc_insertion_point(field_release:v1.SLUError.code)
  
  return code_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SLUError::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  code_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:v1.SLUError.code)
}

// string message = 2;
inline void SLUError::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SLUError::message() const {
  // @@protoc_insertion_point(field_get:v1.SLUError.message)
  return message_.GetNoArena();
}
inline void SLUError::set_message(const std::string& value) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.SLUError.message)
}
inline void SLUError::set_message(std::string&& value) {
  
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.SLUError.message)
}
inline void SLUError::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.SLUError.message)
}
inline void SLUError::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.SLUError.message)
}
inline std::string* SLUError::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:v1.SLUError.message)
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SLUError::release_message() {
  // @@protoc_insertion_point(field_release:v1.SLUError.message)
  
  return message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SLUError::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:v1.SLUError.message)
}

// -------------------------------------------------------------------

// WLURequest

// string language_code = 1;
inline void WLURequest::clear_language_code() {
  language_code_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& WLURequest::language_code() const {
  // @@protoc_insertion_point(field_get:v1.WLURequest.language_code)
  return language_code_.GetNoArena();
}
inline void WLURequest::set_language_code(const std::string& value) {
  
  language_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.WLURequest.language_code)
}
inline void WLURequest::set_language_code(std::string&& value) {
  
  language_code_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.WLURequest.language_code)
}
inline void WLURequest::set_language_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  language_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.WLURequest.language_code)
}
inline void WLURequest::set_language_code(const char* value, size_t size) {
  
  language_code_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.WLURequest.language_code)
}
inline std::string* WLURequest::mutable_language_code() {
  
  // @@protoc_insertion_point(field_mutable:v1.WLURequest.language_code)
  return language_code_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* WLURequest::release_language_code() {
  // @@protoc_insertion_point(field_release:v1.WLURequest.language_code)
  
  return language_code_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void WLURequest::set_allocated_language_code(std::string* language_code) {
  if (language_code != nullptr) {
    
  } else {
    
  }
  language_code_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language_code);
  // @@protoc_insertion_point(field_set_allocated:v1.WLURequest.language_code)
}

// string text = 2;
inline void WLURequest::clear_text() {
  text_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& WLURequest::text() const {
  // @@protoc_insertion_point(field_get:v1.WLURequest.text)
  return text_.GetNoArena();
}
inline void WLURequest::set_text(const std::string& value) {
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.WLURequest.text)
}
inline void WLURequest::set_text(std::string&& value) {
  
  text_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.WLURequest.text)
}
inline void WLURequest::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.WLURequest.text)
}
inline void WLURequest::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.WLURequest.text)
}
inline std::string* WLURequest::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:v1.WLURequest.text)
  return text_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* WLURequest::release_text() {
  // @@protoc_insertion_point(field_release:v1.WLURequest.text)
  
  return text_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void WLURequest::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:v1.WLURequest.text)
}

// -------------------------------------------------------------------

// WLUResponse

// repeated .v1.SLUResponse responses = 1;
inline int WLUResponse::responses_size() const {
  return responses_.size();
}
inline void WLUResponse::clear_responses() {
  responses_.Clear();
}
inline ::v1::SLUResponse* WLUResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:v1.WLUResponse.responses)
  return responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::SLUResponse >*
WLUResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:v1.WLUResponse.responses)
  return &responses_;
}
inline const ::v1::SLUResponse& WLUResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:v1.WLUResponse.responses)
  return responses_.Get(index);
}
inline ::v1::SLUResponse* WLUResponse::add_responses() {
  // @@protoc_insertion_point(field_add:v1.WLUResponse.responses)
  return responses_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::SLUResponse >&
WLUResponse::responses() const {
  // @@protoc_insertion_point(field_list:v1.WLUResponse.responses)
  return responses_;
}

// -------------------------------------------------------------------

// LoginRequest

// string device_id = 1;
inline void LoginRequest::clear_device_id() {
  device_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LoginRequest::device_id() const {
  // @@protoc_insertion_point(field_get:v1.LoginRequest.device_id)
  return device_id_.GetNoArena();
}
inline void LoginRequest::set_device_id(const std::string& value) {
  
  device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.LoginRequest.device_id)
}
inline void LoginRequest::set_device_id(std::string&& value) {
  
  device_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.LoginRequest.device_id)
}
inline void LoginRequest::set_device_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.LoginRequest.device_id)
}
inline void LoginRequest::set_device_id(const char* value, size_t size) {
  
  device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.LoginRequest.device_id)
}
inline std::string* LoginRequest::mutable_device_id() {
  
  // @@protoc_insertion_point(field_mutable:v1.LoginRequest.device_id)
  return device_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginRequest::release_device_id() {
  // @@protoc_insertion_point(field_release:v1.LoginRequest.device_id)
  
  return device_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    
  } else {
    
  }
  device_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_id);
  // @@protoc_insertion_point(field_set_allocated:v1.LoginRequest.device_id)
}

// string app_id = 2;
inline void LoginRequest::clear_app_id() {
  app_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LoginRequest::app_id() const {
  // @@protoc_insertion_point(field_get:v1.LoginRequest.app_id)
  return app_id_.GetNoArena();
}
inline void LoginRequest::set_app_id(const std::string& value) {
  
  app_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.LoginRequest.app_id)
}
inline void LoginRequest::set_app_id(std::string&& value) {
  
  app_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.LoginRequest.app_id)
}
inline void LoginRequest::set_app_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  app_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.LoginRequest.app_id)
}
inline void LoginRequest::set_app_id(const char* value, size_t size) {
  
  app_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.LoginRequest.app_id)
}
inline std::string* LoginRequest::mutable_app_id() {
  
  // @@protoc_insertion_point(field_mutable:v1.LoginRequest.app_id)
  return app_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginRequest::release_app_id() {
  // @@protoc_insertion_point(field_release:v1.LoginRequest.app_id)
  
  return app_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  app_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_id);
  // @@protoc_insertion_point(field_set_allocated:v1.LoginRequest.app_id)
}

// -------------------------------------------------------------------

// LoginResponse

// string token = 1;
inline void LoginResponse::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LoginResponse::token() const {
  // @@protoc_insertion_point(field_get:v1.LoginResponse.token)
  return token_.GetNoArena();
}
inline void LoginResponse::set_token(const std::string& value) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:v1.LoginResponse.token)
}
inline void LoginResponse::set_token(std::string&& value) {
  
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:v1.LoginResponse.token)
}
inline void LoginResponse::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:v1.LoginResponse.token)
}
inline void LoginResponse::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:v1.LoginResponse.token)
}
inline std::string* LoginResponse::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:v1.LoginResponse.token)
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginResponse::release_token() {
  // @@protoc_insertion_point(field_release:v1.LoginResponse.token)
  
  return token_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResponse::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:v1.LoginResponse.token)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::v1::SLUConfig_Encoding> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::v1::SLUConfig_Encoding>() {
  return ::v1::SLUConfig_Encoding_descriptor();
}
template <> struct is_proto_enum< ::v1::SLUEvent_Event> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::v1::SLUEvent_Event>() {
  return ::v1::SLUEvent_Event_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_speechly_2eproto
