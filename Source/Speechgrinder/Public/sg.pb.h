// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sg.proto

#ifndef PROTOBUF_INCLUDED_sg_2eproto
#define PROTOBUF_INCLUDED_sg_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_sg_2eproto 

namespace protobuf_sg_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_sg_2eproto
namespace speechgrinder {
namespace sgapi {
namespace v1 {
class Alternative;
class AlternativeDefaultTypeInternal;
extern AlternativeDefaultTypeInternal _Alternative_default_instance_;
class LoginRequest;
class LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
class LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class SluConfig;
class SluConfigDefaultTypeInternal;
extern SluConfigDefaultTypeInternal _SluConfig_default_instance_;
class SluError;
class SluErrorDefaultTypeInternal;
extern SluErrorDefaultTypeInternal _SluError_default_instance_;
class SluEvent;
class SluEventDefaultTypeInternal;
extern SluEventDefaultTypeInternal _SluEvent_default_instance_;
class SluFinished;
class SluFinishedDefaultTypeInternal;
extern SluFinishedDefaultTypeInternal _SluFinished_default_instance_;
class SluRequest;
class SluRequestDefaultTypeInternal;
extern SluRequestDefaultTypeInternal _SluRequest_default_instance_;
class SluResponse;
class SluResponseDefaultTypeInternal;
extern SluResponseDefaultTypeInternal _SluResponse_default_instance_;
class SluStarted;
class SluStartedDefaultTypeInternal;
extern SluStartedDefaultTypeInternal _SluStarted_default_instance_;
class Token;
class TokenDefaultTypeInternal;
extern TokenDefaultTypeInternal _Token_default_instance_;
class Utterance;
class UtteranceDefaultTypeInternal;
extern UtteranceDefaultTypeInternal _Utterance_default_instance_;
}  // namespace v1
}  // namespace sgapi
}  // namespace speechgrinder
namespace google {
namespace protobuf {
template<> ::speechgrinder::sgapi::v1::Alternative* Arena::CreateMaybeMessage<::speechgrinder::sgapi::v1::Alternative>(Arena*);
template<> ::speechgrinder::sgapi::v1::LoginRequest* Arena::CreateMaybeMessage<::speechgrinder::sgapi::v1::LoginRequest>(Arena*);
template<> ::speechgrinder::sgapi::v1::LoginResponse* Arena::CreateMaybeMessage<::speechgrinder::sgapi::v1::LoginResponse>(Arena*);
template<> ::speechgrinder::sgapi::v1::SluConfig* Arena::CreateMaybeMessage<::speechgrinder::sgapi::v1::SluConfig>(Arena*);
template<> ::speechgrinder::sgapi::v1::SluError* Arena::CreateMaybeMessage<::speechgrinder::sgapi::v1::SluError>(Arena*);
template<> ::speechgrinder::sgapi::v1::SluEvent* Arena::CreateMaybeMessage<::speechgrinder::sgapi::v1::SluEvent>(Arena*);
template<> ::speechgrinder::sgapi::v1::SluFinished* Arena::CreateMaybeMessage<::speechgrinder::sgapi::v1::SluFinished>(Arena*);
template<> ::speechgrinder::sgapi::v1::SluRequest* Arena::CreateMaybeMessage<::speechgrinder::sgapi::v1::SluRequest>(Arena*);
template<> ::speechgrinder::sgapi::v1::SluResponse* Arena::CreateMaybeMessage<::speechgrinder::sgapi::v1::SluResponse>(Arena*);
template<> ::speechgrinder::sgapi::v1::SluStarted* Arena::CreateMaybeMessage<::speechgrinder::sgapi::v1::SluStarted>(Arena*);
template<> ::speechgrinder::sgapi::v1::Token* Arena::CreateMaybeMessage<::speechgrinder::sgapi::v1::Token>(Arena*);
template<> ::speechgrinder::sgapi::v1::Utterance* Arena::CreateMaybeMessage<::speechgrinder::sgapi::v1::Utterance>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace speechgrinder {
namespace sgapi {
namespace v1 {

enum SluConfig_Encoding {
  SluConfig_Encoding_LINEAR16 = 0,
  SluConfig_Encoding_SluConfig_Encoding_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SluConfig_Encoding_SluConfig_Encoding_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SluConfig_Encoding_IsValid(int value);
const SluConfig_Encoding SluConfig_Encoding_Encoding_MIN = SluConfig_Encoding_LINEAR16;
const SluConfig_Encoding SluConfig_Encoding_Encoding_MAX = SluConfig_Encoding_LINEAR16;
const int SluConfig_Encoding_Encoding_ARRAYSIZE = SluConfig_Encoding_Encoding_MAX + 1;

const ::google::protobuf::EnumDescriptor* SluConfig_Encoding_descriptor();
inline const ::std::string& SluConfig_Encoding_Name(SluConfig_Encoding value) {
  return ::google::protobuf::internal::NameOfEnum(
    SluConfig_Encoding_descriptor(), value);
}
inline bool SluConfig_Encoding_Parse(
    const ::std::string& name, SluConfig_Encoding* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SluConfig_Encoding>(
    SluConfig_Encoding_descriptor(), name, value);
}
enum SluEvent_Event {
  SluEvent_Event_START = 0,
  SluEvent_Event_STOP = 1,
  SluEvent_Event_SluEvent_Event_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SluEvent_Event_SluEvent_Event_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SluEvent_Event_IsValid(int value);
const SluEvent_Event SluEvent_Event_Event_MIN = SluEvent_Event_START;
const SluEvent_Event SluEvent_Event_Event_MAX = SluEvent_Event_STOP;
const int SluEvent_Event_Event_ARRAYSIZE = SluEvent_Event_Event_MAX + 1;

const ::google::protobuf::EnumDescriptor* SluEvent_Event_descriptor();
inline const ::std::string& SluEvent_Event_Name(SluEvent_Event value) {
  return ::google::protobuf::internal::NameOfEnum(
    SluEvent_Event_descriptor(), value);
}
inline bool SluEvent_Event_Parse(
    const ::std::string& name, SluEvent_Event* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SluEvent_Event>(
    SluEvent_Event_descriptor(), name, value);
}
enum Token_TokenPosition {
  Token_TokenPosition_outsideOf = 0,
  Token_TokenPosition_startOf = 1,
  Token_TokenPosition_insideOf = 2,
  Token_TokenPosition_Token_TokenPosition_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Token_TokenPosition_Token_TokenPosition_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Token_TokenPosition_IsValid(int value);
const Token_TokenPosition Token_TokenPosition_TokenPosition_MIN = Token_TokenPosition_outsideOf;
const Token_TokenPosition Token_TokenPosition_TokenPosition_MAX = Token_TokenPosition_insideOf;
const int Token_TokenPosition_TokenPosition_ARRAYSIZE = Token_TokenPosition_TokenPosition_MAX + 1;

const ::google::protobuf::EnumDescriptor* Token_TokenPosition_descriptor();
inline const ::std::string& Token_TokenPosition_Name(Token_TokenPosition value) {
  return ::google::protobuf::internal::NameOfEnum(
    Token_TokenPosition_descriptor(), value);
}
inline bool Token_TokenPosition_Parse(
    const ::std::string& name, Token_TokenPosition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Token_TokenPosition>(
    Token_TokenPosition_descriptor(), name, value);
}
// ===================================================================

class SluRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechgrinder.sgapi.v1.SluRequest) */ {
 public:
  SluRequest();
  virtual ~SluRequest();

  SluRequest(const SluRequest& from);

  inline SluRequest& operator=(const SluRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SluRequest(SluRequest&& from) noexcept
    : SluRequest() {
    *this = ::std::move(from);
  }

  inline SluRequest& operator=(SluRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SluRequest& default_instance();

  enum StreamingRequestCase {
    kConfig = 1,
    kEvent = 2,
    kAudio = 3,
    STREAMING_REQUEST_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SluRequest* internal_default_instance() {
    return reinterpret_cast<const SluRequest*>(
               &_SluRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SluRequest* other);
  friend void swap(SluRequest& a, SluRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SluRequest* New() const final {
    return CreateMaybeMessage<SluRequest>(NULL);
  }

  SluRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SluRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SluRequest& from);
  void MergeFrom(const SluRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SluRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .speechgrinder.sgapi.v1.SluConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  private:
  const ::speechgrinder::sgapi::v1::SluConfig& _internal_config() const;
  public:
  const ::speechgrinder::sgapi::v1::SluConfig& config() const;
  ::speechgrinder::sgapi::v1::SluConfig* release_config();
  ::speechgrinder::sgapi::v1::SluConfig* mutable_config();
  void set_allocated_config(::speechgrinder::sgapi::v1::SluConfig* config);

  // .speechgrinder.sgapi.v1.SluEvent event = 2;
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 2;
  private:
  const ::speechgrinder::sgapi::v1::SluEvent& _internal_event() const;
  public:
  const ::speechgrinder::sgapi::v1::SluEvent& event() const;
  ::speechgrinder::sgapi::v1::SluEvent* release_event();
  ::speechgrinder::sgapi::v1::SluEvent* mutable_event();
  void set_allocated_event(::speechgrinder::sgapi::v1::SluEvent* event);

  // bytes audio = 3;
  private:
  bool has_audio() const;
  public:
  void clear_audio();
  static const int kAudioFieldNumber = 3;
  const ::std::string& audio() const;
  void set_audio(const ::std::string& value);
  #if LANG_CXX11
  void set_audio(::std::string&& value);
  #endif
  void set_audio(const char* value);
  void set_audio(const void* value, size_t size);
  ::std::string* mutable_audio();
  ::std::string* release_audio();
  void set_allocated_audio(::std::string* audio);

  void clear_streaming_request();
  StreamingRequestCase streaming_request_case() const;
  // @@protoc_insertion_point(class_scope:speechgrinder.sgapi.v1.SluRequest)
 private:
  void set_has_config();
  void set_has_event();
  void set_has_audio();

  inline bool has_streaming_request() const;
  inline void clear_has_streaming_request();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union StreamingRequestUnion {
    StreamingRequestUnion() {}
    ::speechgrinder::sgapi::v1::SluConfig* config_;
    ::speechgrinder::sgapi::v1::SluEvent* event_;
    ::google::protobuf::internal::ArenaStringPtr audio_;
  } streaming_request_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_sg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SluConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechgrinder.sgapi.v1.SluConfig) */ {
 public:
  SluConfig();
  virtual ~SluConfig();

  SluConfig(const SluConfig& from);

  inline SluConfig& operator=(const SluConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SluConfig(SluConfig&& from) noexcept
    : SluConfig() {
    *this = ::std::move(from);
  }

  inline SluConfig& operator=(SluConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SluConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SluConfig* internal_default_instance() {
    return reinterpret_cast<const SluConfig*>(
               &_SluConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SluConfig* other);
  friend void swap(SluConfig& a, SluConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SluConfig* New() const final {
    return CreateMaybeMessage<SluConfig>(NULL);
  }

  SluConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SluConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SluConfig& from);
  void MergeFrom(const SluConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SluConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SluConfig_Encoding Encoding;
  static const Encoding LINEAR16 =
    SluConfig_Encoding_LINEAR16;
  static inline bool Encoding_IsValid(int value) {
    return SluConfig_Encoding_IsValid(value);
  }
  static const Encoding Encoding_MIN =
    SluConfig_Encoding_Encoding_MIN;
  static const Encoding Encoding_MAX =
    SluConfig_Encoding_Encoding_MAX;
  static const int Encoding_ARRAYSIZE =
    SluConfig_Encoding_Encoding_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Encoding_descriptor() {
    return SluConfig_Encoding_descriptor();
  }
  static inline const ::std::string& Encoding_Name(Encoding value) {
    return SluConfig_Encoding_Name(value);
  }
  static inline bool Encoding_Parse(const ::std::string& name,
      Encoding* value) {
    return SluConfig_Encoding_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string language_code = 4;
  void clear_language_code();
  static const int kLanguageCodeFieldNumber = 4;
  const ::std::string& language_code() const;
  void set_language_code(const ::std::string& value);
  #if LANG_CXX11
  void set_language_code(::std::string&& value);
  #endif
  void set_language_code(const char* value);
  void set_language_code(const char* value, size_t size);
  ::std::string* mutable_language_code();
  ::std::string* release_language_code();
  void set_allocated_language_code(::std::string* language_code);

  // .speechgrinder.sgapi.v1.SluConfig.Encoding encoding = 1;
  void clear_encoding();
  static const int kEncodingFieldNumber = 1;
  ::speechgrinder::sgapi::v1::SluConfig_Encoding encoding() const;
  void set_encoding(::speechgrinder::sgapi::v1::SluConfig_Encoding value);

  // int32 channels = 2;
  void clear_channels();
  static const int kChannelsFieldNumber = 2;
  ::google::protobuf::int32 channels() const;
  void set_channels(::google::protobuf::int32 value);

  // int32 sample_rate_hertz = 3;
  void clear_sample_rate_hertz();
  static const int kSampleRateHertzFieldNumber = 3;
  ::google::protobuf::int32 sample_rate_hertz() const;
  void set_sample_rate_hertz(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:speechgrinder.sgapi.v1.SluConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr language_code_;
  int encoding_;
  ::google::protobuf::int32 channels_;
  ::google::protobuf::int32 sample_rate_hertz_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SluEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechgrinder.sgapi.v1.SluEvent) */ {
 public:
  SluEvent();
  virtual ~SluEvent();

  SluEvent(const SluEvent& from);

  inline SluEvent& operator=(const SluEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SluEvent(SluEvent&& from) noexcept
    : SluEvent() {
    *this = ::std::move(from);
  }

  inline SluEvent& operator=(SluEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SluEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SluEvent* internal_default_instance() {
    return reinterpret_cast<const SluEvent*>(
               &_SluEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SluEvent* other);
  friend void swap(SluEvent& a, SluEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SluEvent* New() const final {
    return CreateMaybeMessage<SluEvent>(NULL);
  }

  SluEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SluEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SluEvent& from);
  void MergeFrom(const SluEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SluEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SluEvent_Event Event;
  static const Event START =
    SluEvent_Event_START;
  static const Event STOP =
    SluEvent_Event_STOP;
  static inline bool Event_IsValid(int value) {
    return SluEvent_Event_IsValid(value);
  }
  static const Event Event_MIN =
    SluEvent_Event_Event_MIN;
  static const Event Event_MAX =
    SluEvent_Event_Event_MAX;
  static const int Event_ARRAYSIZE =
    SluEvent_Event_Event_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Event_descriptor() {
    return SluEvent_Event_descriptor();
  }
  static inline const ::std::string& Event_Name(Event value) {
    return SluEvent_Event_Name(value);
  }
  static inline bool Event_Parse(const ::std::string& name,
      Event* value) {
    return SluEvent_Event_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .speechgrinder.sgapi.v1.SluEvent.Event event = 1;
  void clear_event();
  static const int kEventFieldNumber = 1;
  ::speechgrinder::sgapi::v1::SluEvent_Event event() const;
  void set_event(::speechgrinder::sgapi::v1::SluEvent_Event value);

  // @@protoc_insertion_point(class_scope:speechgrinder.sgapi.v1.SluEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int event_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SluResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechgrinder.sgapi.v1.SluResponse) */ {
 public:
  SluResponse();
  virtual ~SluResponse();

  SluResponse(const SluResponse& from);

  inline SluResponse& operator=(const SluResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SluResponse(SluResponse&& from) noexcept
    : SluResponse() {
    *this = ::std::move(from);
  }

  inline SluResponse& operator=(SluResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SluResponse& default_instance();

  enum StreamingResponseCase {
    kStarted = 1,
    kUtterance = 2,
    kFinished = 3,
    STREAMING_RESPONSE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SluResponse* internal_default_instance() {
    return reinterpret_cast<const SluResponse*>(
               &_SluResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SluResponse* other);
  friend void swap(SluResponse& a, SluResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SluResponse* New() const final {
    return CreateMaybeMessage<SluResponse>(NULL);
  }

  SluResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SluResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SluResponse& from);
  void MergeFrom(const SluResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SluResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .speechgrinder.sgapi.v1.SluStarted started = 1;
  bool has_started() const;
  void clear_started();
  static const int kStartedFieldNumber = 1;
  private:
  const ::speechgrinder::sgapi::v1::SluStarted& _internal_started() const;
  public:
  const ::speechgrinder::sgapi::v1::SluStarted& started() const;
  ::speechgrinder::sgapi::v1::SluStarted* release_started();
  ::speechgrinder::sgapi::v1::SluStarted* mutable_started();
  void set_allocated_started(::speechgrinder::sgapi::v1::SluStarted* started);

  // .speechgrinder.sgapi.v1.Utterance utterance = 2;
  bool has_utterance() const;
  void clear_utterance();
  static const int kUtteranceFieldNumber = 2;
  private:
  const ::speechgrinder::sgapi::v1::Utterance& _internal_utterance() const;
  public:
  const ::speechgrinder::sgapi::v1::Utterance& utterance() const;
  ::speechgrinder::sgapi::v1::Utterance* release_utterance();
  ::speechgrinder::sgapi::v1::Utterance* mutable_utterance();
  void set_allocated_utterance(::speechgrinder::sgapi::v1::Utterance* utterance);

  // .speechgrinder.sgapi.v1.SluFinished finished = 3;
  bool has_finished() const;
  void clear_finished();
  static const int kFinishedFieldNumber = 3;
  private:
  const ::speechgrinder::sgapi::v1::SluFinished& _internal_finished() const;
  public:
  const ::speechgrinder::sgapi::v1::SluFinished& finished() const;
  ::speechgrinder::sgapi::v1::SluFinished* release_finished();
  ::speechgrinder::sgapi::v1::SluFinished* mutable_finished();
  void set_allocated_finished(::speechgrinder::sgapi::v1::SluFinished* finished);

  void clear_streaming_response();
  StreamingResponseCase streaming_response_case() const;
  // @@protoc_insertion_point(class_scope:speechgrinder.sgapi.v1.SluResponse)
 private:
  void set_has_started();
  void set_has_utterance();
  void set_has_finished();

  inline bool has_streaming_response() const;
  inline void clear_has_streaming_response();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union StreamingResponseUnion {
    StreamingResponseUnion() {}
    ::speechgrinder::sgapi::v1::SluStarted* started_;
    ::speechgrinder::sgapi::v1::Utterance* utterance_;
    ::speechgrinder::sgapi::v1::SluFinished* finished_;
  } streaming_response_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_sg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SluStarted : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechgrinder.sgapi.v1.SluStarted) */ {
 public:
  SluStarted();
  virtual ~SluStarted();

  SluStarted(const SluStarted& from);

  inline SluStarted& operator=(const SluStarted& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SluStarted(SluStarted&& from) noexcept
    : SluStarted() {
    *this = ::std::move(from);
  }

  inline SluStarted& operator=(SluStarted&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SluStarted& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SluStarted* internal_default_instance() {
    return reinterpret_cast<const SluStarted*>(
               &_SluStarted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SluStarted* other);
  friend void swap(SluStarted& a, SluStarted& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SluStarted* New() const final {
    return CreateMaybeMessage<SluStarted>(NULL);
  }

  SluStarted* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SluStarted>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SluStarted& from);
  void MergeFrom(const SluStarted& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SluStarted* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string utterance_id = 1;
  void clear_utterance_id();
  static const int kUtteranceIdFieldNumber = 1;
  const ::std::string& utterance_id() const;
  void set_utterance_id(const ::std::string& value);
  #if LANG_CXX11
  void set_utterance_id(::std::string&& value);
  #endif
  void set_utterance_id(const char* value);
  void set_utterance_id(const char* value, size_t size);
  ::std::string* mutable_utterance_id();
  ::std::string* release_utterance_id();
  void set_allocated_utterance_id(::std::string* utterance_id);

  // @@protoc_insertion_point(class_scope:speechgrinder.sgapi.v1.SluStarted)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr utterance_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SluFinished : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechgrinder.sgapi.v1.SluFinished) */ {
 public:
  SluFinished();
  virtual ~SluFinished();

  SluFinished(const SluFinished& from);

  inline SluFinished& operator=(const SluFinished& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SluFinished(SluFinished&& from) noexcept
    : SluFinished() {
    *this = ::std::move(from);
  }

  inline SluFinished& operator=(SluFinished&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SluFinished& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SluFinished* internal_default_instance() {
    return reinterpret_cast<const SluFinished*>(
               &_SluFinished_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(SluFinished* other);
  friend void swap(SluFinished& a, SluFinished& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SluFinished* New() const final {
    return CreateMaybeMessage<SluFinished>(NULL);
  }

  SluFinished* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SluFinished>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SluFinished& from);
  void MergeFrom(const SluFinished& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SluFinished* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string utterance_id = 1;
  void clear_utterance_id();
  static const int kUtteranceIdFieldNumber = 1;
  const ::std::string& utterance_id() const;
  void set_utterance_id(const ::std::string& value);
  #if LANG_CXX11
  void set_utterance_id(::std::string&& value);
  #endif
  void set_utterance_id(const char* value);
  void set_utterance_id(const char* value, size_t size);
  ::std::string* mutable_utterance_id();
  ::std::string* release_utterance_id();
  void set_allocated_utterance_id(::std::string* utterance_id);

  // .speechgrinder.sgapi.v1.SluError error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  private:
  const ::speechgrinder::sgapi::v1::SluError& _internal_error() const;
  public:
  const ::speechgrinder::sgapi::v1::SluError& error() const;
  ::speechgrinder::sgapi::v1::SluError* release_error();
  ::speechgrinder::sgapi::v1::SluError* mutable_error();
  void set_allocated_error(::speechgrinder::sgapi::v1::SluError* error);

  // @@protoc_insertion_point(class_scope:speechgrinder.sgapi.v1.SluFinished)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr utterance_id_;
  ::speechgrinder::sgapi::v1::SluError* error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SluError : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechgrinder.sgapi.v1.SluError) */ {
 public:
  SluError();
  virtual ~SluError();

  SluError(const SluError& from);

  inline SluError& operator=(const SluError& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SluError(SluError&& from) noexcept
    : SluError() {
    *this = ::std::move(from);
  }

  inline SluError& operator=(SluError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SluError& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SluError* internal_default_instance() {
    return reinterpret_cast<const SluError*>(
               &_SluError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SluError* other);
  friend void swap(SluError& a, SluError& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SluError* New() const final {
    return CreateMaybeMessage<SluError>(NULL);
  }

  SluError* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SluError>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SluError& from);
  void MergeFrom(const SluError& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SluError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  #if LANG_CXX11
  void set_code(::std::string&& value);
  #endif
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:speechgrinder.sgapi.v1.SluError)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Utterance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechgrinder.sgapi.v1.Utterance) */ {
 public:
  Utterance();
  virtual ~Utterance();

  Utterance(const Utterance& from);

  inline Utterance& operator=(const Utterance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Utterance(Utterance&& from) noexcept
    : Utterance() {
    *this = ::std::move(from);
  }

  inline Utterance& operator=(Utterance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Utterance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Utterance* internal_default_instance() {
    return reinterpret_cast<const Utterance*>(
               &_Utterance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Utterance* other);
  friend void swap(Utterance& a, Utterance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Utterance* New() const final {
    return CreateMaybeMessage<Utterance>(NULL);
  }

  Utterance* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Utterance>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Utterance& from);
  void MergeFrom(const Utterance& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Utterance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .speechgrinder.sgapi.v1.Alternative alternatives = 4;
  int alternatives_size() const;
  void clear_alternatives();
  static const int kAlternativesFieldNumber = 4;
  ::speechgrinder::sgapi::v1::Alternative* mutable_alternatives(int index);
  ::google::protobuf::RepeatedPtrField< ::speechgrinder::sgapi::v1::Alternative >*
      mutable_alternatives();
  const ::speechgrinder::sgapi::v1::Alternative& alternatives(int index) const;
  ::speechgrinder::sgapi::v1::Alternative* add_alternatives();
  const ::google::protobuf::RepeatedPtrField< ::speechgrinder::sgapi::v1::Alternative >&
      alternatives() const;

  // string utterance_id = 1;
  void clear_utterance_id();
  static const int kUtteranceIdFieldNumber = 1;
  const ::std::string& utterance_id() const;
  void set_utterance_id(const ::std::string& value);
  #if LANG_CXX11
  void set_utterance_id(::std::string&& value);
  #endif
  void set_utterance_id(const char* value);
  void set_utterance_id(const char* value, size_t size);
  ::std::string* mutable_utterance_id();
  ::std::string* release_utterance_id();
  void set_allocated_utterance_id(::std::string* utterance_id);

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string language_code = 3;
  void clear_language_code();
  static const int kLanguageCodeFieldNumber = 3;
  const ::std::string& language_code() const;
  void set_language_code(const ::std::string& value);
  #if LANG_CXX11
  void set_language_code(::std::string&& value);
  #endif
  void set_language_code(const char* value);
  void set_language_code(const char* value, size_t size);
  ::std::string* mutable_language_code();
  ::std::string* release_language_code();
  void set_allocated_language_code(::std::string* language_code);

  // @@protoc_insertion_point(class_scope:speechgrinder.sgapi.v1.Utterance)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::speechgrinder::sgapi::v1::Alternative > alternatives_;
  ::google::protobuf::internal::ArenaStringPtr utterance_id_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr language_code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Alternative : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechgrinder.sgapi.v1.Alternative) */ {
 public:
  Alternative();
  virtual ~Alternative();

  Alternative(const Alternative& from);

  inline Alternative& operator=(const Alternative& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Alternative(Alternative&& from) noexcept
    : Alternative() {
    *this = ::std::move(from);
  }

  inline Alternative& operator=(Alternative&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Alternative& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Alternative* internal_default_instance() {
    return reinterpret_cast<const Alternative*>(
               &_Alternative_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Alternative* other);
  friend void swap(Alternative& a, Alternative& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Alternative* New() const final {
    return CreateMaybeMessage<Alternative>(NULL);
  }

  Alternative* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Alternative>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Alternative& from);
  void MergeFrom(const Alternative& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Alternative* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .speechgrinder.sgapi.v1.Token tokens = 2;
  int tokens_size() const;
  void clear_tokens();
  static const int kTokensFieldNumber = 2;
  ::speechgrinder::sgapi::v1::Token* mutable_tokens(int index);
  ::google::protobuf::RepeatedPtrField< ::speechgrinder::sgapi::v1::Token >*
      mutable_tokens();
  const ::speechgrinder::sgapi::v1::Token& tokens(int index) const;
  ::speechgrinder::sgapi::v1::Token* add_tokens();
  const ::google::protobuf::RepeatedPtrField< ::speechgrinder::sgapi::v1::Token >&
      tokens() const;

  // float confidence = 1;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 1;
  float confidence() const;
  void set_confidence(float value);

  // @@protoc_insertion_point(class_scope:speechgrinder.sgapi.v1.Alternative)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::speechgrinder::sgapi::v1::Token > tokens_;
  float confidence_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Token : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechgrinder.sgapi.v1.Token) */ {
 public:
  Token();
  virtual ~Token();

  Token(const Token& from);

  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Token(Token&& from) noexcept
    : Token() {
    *this = ::std::move(from);
  }

  inline Token& operator=(Token&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Token& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Token* internal_default_instance() {
    return reinterpret_cast<const Token*>(
               &_Token_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Token* other);
  friend void swap(Token& a, Token& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Token* New() const final {
    return CreateMaybeMessage<Token>(NULL);
  }

  Token* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Token>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Token& from);
  void MergeFrom(const Token& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Token* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Token_TokenPosition TokenPosition;
  static const TokenPosition outsideOf =
    Token_TokenPosition_outsideOf;
  static const TokenPosition startOf =
    Token_TokenPosition_startOf;
  static const TokenPosition insideOf =
    Token_TokenPosition_insideOf;
  static inline bool TokenPosition_IsValid(int value) {
    return Token_TokenPosition_IsValid(value);
  }
  static const TokenPosition TokenPosition_MIN =
    Token_TokenPosition_TokenPosition_MIN;
  static const TokenPosition TokenPosition_MAX =
    Token_TokenPosition_TokenPosition_MAX;
  static const int TokenPosition_ARRAYSIZE =
    Token_TokenPosition_TokenPosition_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TokenPosition_descriptor() {
    return Token_TokenPosition_descriptor();
  }
  static inline const ::std::string& TokenPosition_Name(TokenPosition value) {
    return Token_TokenPosition_Name(value);
  }
  static inline bool TokenPosition_Parse(const ::std::string& name,
      TokenPosition* value) {
    return Token_TokenPosition_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string text = 1;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // string text_with_trailing_space = 2;
  void clear_text_with_trailing_space();
  static const int kTextWithTrailingSpaceFieldNumber = 2;
  const ::std::string& text_with_trailing_space() const;
  void set_text_with_trailing_space(const ::std::string& value);
  #if LANG_CXX11
  void set_text_with_trailing_space(::std::string&& value);
  #endif
  void set_text_with_trailing_space(const char* value);
  void set_text_with_trailing_space(const char* value, size_t size);
  ::std::string* mutable_text_with_trailing_space();
  ::std::string* release_text_with_trailing_space();
  void set_allocated_text_with_trailing_space(::std::string* text_with_trailing_space);

  // string lemma = 3;
  void clear_lemma();
  static const int kLemmaFieldNumber = 3;
  const ::std::string& lemma() const;
  void set_lemma(const ::std::string& value);
  #if LANG_CXX11
  void set_lemma(::std::string&& value);
  #endif
  void set_lemma(const char* value);
  void set_lemma(const char* value, size_t size);
  ::std::string* mutable_lemma();
  ::std::string* release_lemma();
  void set_allocated_lemma(::std::string* lemma);

  // string pos = 4;
  void clear_pos();
  static const int kPosFieldNumber = 4;
  const ::std::string& pos() const;
  void set_pos(const ::std::string& value);
  #if LANG_CXX11
  void set_pos(::std::string&& value);
  #endif
  void set_pos(const char* value);
  void set_pos(const char* value, size_t size);
  ::std::string* mutable_pos();
  ::std::string* release_pos();
  void set_allocated_pos(::std::string* pos);

  // string tag = 5;
  void clear_tag();
  static const int kTagFieldNumber = 5;
  const ::std::string& tag() const;
  void set_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_tag(::std::string&& value);
  #endif
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  ::std::string* mutable_tag();
  ::std::string* release_tag();
  void set_allocated_tag(::std::string* tag);

  // string case = 6;
  void clear_case_();
  static const int kCaseFieldNumber = 6;
  const ::std::string& case_() const;
  void set_case_(const ::std::string& value);
  #if LANG_CXX11
  void set_case_(::std::string&& value);
  #endif
  void set_case_(const char* value);
  void set_case_(const char* value, size_t size);
  ::std::string* mutable_case_();
  ::std::string* release_case_();
  void set_allocated_case_(::std::string* case_);

  // string number = 7;
  void clear_number();
  static const int kNumberFieldNumber = 7;
  const ::std::string& number() const;
  void set_number(const ::std::string& value);
  #if LANG_CXX11
  void set_number(::std::string&& value);
  #endif
  void set_number(const char* value);
  void set_number(const char* value, size_t size);
  ::std::string* mutable_number();
  ::std::string* release_number();
  void set_allocated_number(::std::string* number);

  // string entity_type = 8;
  void clear_entity_type();
  static const int kEntityTypeFieldNumber = 8;
  const ::std::string& entity_type() const;
  void set_entity_type(const ::std::string& value);
  #if LANG_CXX11
  void set_entity_type(::std::string&& value);
  #endif
  void set_entity_type(const char* value);
  void set_entity_type(const char* value, size_t size);
  ::std::string* mutable_entity_type();
  ::std::string* release_entity_type();
  void set_allocated_entity_type(::std::string* entity_type);

  // .speechgrinder.sgapi.v1.Token.TokenPosition position_in_entity = 9;
  void clear_position_in_entity();
  static const int kPositionInEntityFieldNumber = 9;
  ::speechgrinder::sgapi::v1::Token_TokenPosition position_in_entity() const;
  void set_position_in_entity(::speechgrinder::sgapi::v1::Token_TokenPosition value);

  // bool is_segment_start = 10;
  void clear_is_segment_start();
  static const int kIsSegmentStartFieldNumber = 10;
  bool is_segment_start() const;
  void set_is_segment_start(bool value);

  // int32 trailing_silence = 11;
  void clear_trailing_silence();
  static const int kTrailingSilenceFieldNumber = 11;
  ::google::protobuf::int32 trailing_silence() const;
  void set_trailing_silence(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:speechgrinder.sgapi.v1.Token)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr text_with_trailing_space_;
  ::google::protobuf::internal::ArenaStringPtr lemma_;
  ::google::protobuf::internal::ArenaStringPtr pos_;
  ::google::protobuf::internal::ArenaStringPtr tag_;
  ::google::protobuf::internal::ArenaStringPtr case__;
  ::google::protobuf::internal::ArenaStringPtr number_;
  ::google::protobuf::internal::ArenaStringPtr entity_type_;
  int position_in_entity_;
  bool is_segment_start_;
  ::google::protobuf::int32 trailing_silence_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechgrinder.sgapi.v1.LoginRequest) */ {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(LoginRequest* other);
  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const final {
    return CreateMaybeMessage<LoginRequest>(NULL);
  }

  LoginRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string device_id = 1;
  void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  const ::std::string& device_id() const;
  void set_device_id(const ::std::string& value);
  #if LANG_CXX11
  void set_device_id(::std::string&& value);
  #endif
  void set_device_id(const char* value);
  void set_device_id(const char* value, size_t size);
  ::std::string* mutable_device_id();
  ::std::string* release_device_id();
  void set_allocated_device_id(::std::string* device_id);

  // string app_id = 2;
  void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  const ::std::string& app_id() const;
  void set_app_id(const ::std::string& value);
  #if LANG_CXX11
  void set_app_id(::std::string&& value);
  #endif
  void set_app_id(const char* value);
  void set_app_id(const char* value, size_t size);
  ::std::string* mutable_app_id();
  ::std::string* release_app_id();
  void set_allocated_app_id(::std::string* app_id);

  // @@protoc_insertion_point(class_scope:speechgrinder.sgapi.v1.LoginRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr device_id_;
  ::google::protobuf::internal::ArenaStringPtr app_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechgrinder.sgapi.v1.LoginResponse) */ {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(LoginResponse* other);
  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginResponse* New() const final {
    return CreateMaybeMessage<LoginResponse>(NULL);
  }

  LoginResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string token = 1;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:speechgrinder.sgapi.v1.LoginResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sg_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SluRequest

// .speechgrinder.sgapi.v1.SluConfig config = 1;
inline bool SluRequest::has_config() const {
  return streaming_request_case() == kConfig;
}
inline void SluRequest::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void SluRequest::clear_config() {
  if (has_config()) {
    delete streaming_request_.config_;
    clear_has_streaming_request();
  }
}
inline const ::speechgrinder::sgapi::v1::SluConfig& SluRequest::_internal_config() const {
  return *streaming_request_.config_;
}
inline ::speechgrinder::sgapi::v1::SluConfig* SluRequest::release_config() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.SluRequest.config)
  if (has_config()) {
    clear_has_streaming_request();
      ::speechgrinder::sgapi::v1::SluConfig* temp = streaming_request_.config_;
    streaming_request_.config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::speechgrinder::sgapi::v1::SluConfig& SluRequest::config() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.SluRequest.config)
  return has_config()
      ? *streaming_request_.config_
      : *reinterpret_cast< ::speechgrinder::sgapi::v1::SluConfig*>(&::speechgrinder::sgapi::v1::_SluConfig_default_instance_);
}
inline ::speechgrinder::sgapi::v1::SluConfig* SluRequest::mutable_config() {
  if (!has_config()) {
    clear_streaming_request();
    set_has_config();
    streaming_request_.config_ = CreateMaybeMessage< ::speechgrinder::sgapi::v1::SluConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.SluRequest.config)
  return streaming_request_.config_;
}

// .speechgrinder.sgapi.v1.SluEvent event = 2;
inline bool SluRequest::has_event() const {
  return streaming_request_case() == kEvent;
}
inline void SluRequest::set_has_event() {
  _oneof_case_[0] = kEvent;
}
inline void SluRequest::clear_event() {
  if (has_event()) {
    delete streaming_request_.event_;
    clear_has_streaming_request();
  }
}
inline const ::speechgrinder::sgapi::v1::SluEvent& SluRequest::_internal_event() const {
  return *streaming_request_.event_;
}
inline ::speechgrinder::sgapi::v1::SluEvent* SluRequest::release_event() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.SluRequest.event)
  if (has_event()) {
    clear_has_streaming_request();
      ::speechgrinder::sgapi::v1::SluEvent* temp = streaming_request_.event_;
    streaming_request_.event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::speechgrinder::sgapi::v1::SluEvent& SluRequest::event() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.SluRequest.event)
  return has_event()
      ? *streaming_request_.event_
      : *reinterpret_cast< ::speechgrinder::sgapi::v1::SluEvent*>(&::speechgrinder::sgapi::v1::_SluEvent_default_instance_);
}
inline ::speechgrinder::sgapi::v1::SluEvent* SluRequest::mutable_event() {
  if (!has_event()) {
    clear_streaming_request();
    set_has_event();
    streaming_request_.event_ = CreateMaybeMessage< ::speechgrinder::sgapi::v1::SluEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.SluRequest.event)
  return streaming_request_.event_;
}

// bytes audio = 3;
inline bool SluRequest::has_audio() const {
  return streaming_request_case() == kAudio;
}
inline void SluRequest::set_has_audio() {
  _oneof_case_[0] = kAudio;
}
inline void SluRequest::clear_audio() {
  if (has_audio()) {
    streaming_request_.audio_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_streaming_request();
  }
}
inline const ::std::string& SluRequest::audio() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.SluRequest.audio)
  if (has_audio()) {
    return streaming_request_.audio_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void SluRequest::set_audio(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.SluRequest.audio)
  if (!has_audio()) {
    clear_streaming_request();
    set_has_audio();
    streaming_request_.audio_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  streaming_request_.audio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.SluRequest.audio)
}
#if LANG_CXX11
inline void SluRequest::set_audio(::std::string&& value) {
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.SluRequest.audio)
  if (!has_audio()) {
    clear_streaming_request();
    set_has_audio();
    streaming_request_.audio_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  streaming_request_.audio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.SluRequest.audio)
}
#endif
inline void SluRequest::set_audio(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_audio()) {
    clear_streaming_request();
    set_has_audio();
    streaming_request_.audio_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  streaming_request_.audio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.SluRequest.audio)
}
inline void SluRequest::set_audio(const void* value, size_t size) {
  if (!has_audio()) {
    clear_streaming_request();
    set_has_audio();
    streaming_request_.audio_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  streaming_request_.audio_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.SluRequest.audio)
}
inline ::std::string* SluRequest::mutable_audio() {
  if (!has_audio()) {
    clear_streaming_request();
    set_has_audio();
    streaming_request_.audio_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.SluRequest.audio)
  return streaming_request_.audio_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SluRequest::release_audio() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.SluRequest.audio)
  if (has_audio()) {
    clear_has_streaming_request();
    return streaming_request_.audio_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void SluRequest::set_allocated_audio(::std::string* audio) {
  if (!has_audio()) {
    streaming_request_.audio_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_streaming_request();
  if (audio != NULL) {
    set_has_audio();
    streaming_request_.audio_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), audio);
  }
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.SluRequest.audio)
}

inline bool SluRequest::has_streaming_request() const {
  return streaming_request_case() != STREAMING_REQUEST_NOT_SET;
}
inline void SluRequest::clear_has_streaming_request() {
  _oneof_case_[0] = STREAMING_REQUEST_NOT_SET;
}
inline SluRequest::StreamingRequestCase SluRequest::streaming_request_case() const {
  return SluRequest::StreamingRequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SluConfig

// .speechgrinder.sgapi.v1.SluConfig.Encoding encoding = 1;
inline void SluConfig::clear_encoding() {
  encoding_ = 0;
}
inline ::speechgrinder::sgapi::v1::SluConfig_Encoding SluConfig::encoding() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.SluConfig.encoding)
  return static_cast< ::speechgrinder::sgapi::v1::SluConfig_Encoding >(encoding_);
}
inline void SluConfig::set_encoding(::speechgrinder::sgapi::v1::SluConfig_Encoding value) {
  
  encoding_ = value;
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.SluConfig.encoding)
}

// int32 channels = 2;
inline void SluConfig::clear_channels() {
  channels_ = 0;
}
inline ::google::protobuf::int32 SluConfig::channels() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.SluConfig.channels)
  return channels_;
}
inline void SluConfig::set_channels(::google::protobuf::int32 value) {
  
  channels_ = value;
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.SluConfig.channels)
}

// int32 sample_rate_hertz = 3;
inline void SluConfig::clear_sample_rate_hertz() {
  sample_rate_hertz_ = 0;
}
inline ::google::protobuf::int32 SluConfig::sample_rate_hertz() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.SluConfig.sample_rate_hertz)
  return sample_rate_hertz_;
}
inline void SluConfig::set_sample_rate_hertz(::google::protobuf::int32 value) {
  
  sample_rate_hertz_ = value;
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.SluConfig.sample_rate_hertz)
}

// string language_code = 4;
inline void SluConfig::clear_language_code() {
  language_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SluConfig::language_code() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.SluConfig.language_code)
  return language_code_.GetNoArena();
}
inline void SluConfig::set_language_code(const ::std::string& value) {
  
  language_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.SluConfig.language_code)
}
#if LANG_CXX11
inline void SluConfig::set_language_code(::std::string&& value) {
  
  language_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.SluConfig.language_code)
}
#endif
inline void SluConfig::set_language_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  language_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.SluConfig.language_code)
}
inline void SluConfig::set_language_code(const char* value, size_t size) {
  
  language_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.SluConfig.language_code)
}
inline ::std::string* SluConfig::mutable_language_code() {
  
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.SluConfig.language_code)
  return language_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SluConfig::release_language_code() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.SluConfig.language_code)
  
  return language_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SluConfig::set_allocated_language_code(::std::string* language_code) {
  if (language_code != NULL) {
    
  } else {
    
  }
  language_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language_code);
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.SluConfig.language_code)
}

// -------------------------------------------------------------------

// SluEvent

// .speechgrinder.sgapi.v1.SluEvent.Event event = 1;
inline void SluEvent::clear_event() {
  event_ = 0;
}
inline ::speechgrinder::sgapi::v1::SluEvent_Event SluEvent::event() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.SluEvent.event)
  return static_cast< ::speechgrinder::sgapi::v1::SluEvent_Event >(event_);
}
inline void SluEvent::set_event(::speechgrinder::sgapi::v1::SluEvent_Event value) {
  
  event_ = value;
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.SluEvent.event)
}

// -------------------------------------------------------------------

// SluResponse

// .speechgrinder.sgapi.v1.SluStarted started = 1;
inline bool SluResponse::has_started() const {
  return streaming_response_case() == kStarted;
}
inline void SluResponse::set_has_started() {
  _oneof_case_[0] = kStarted;
}
inline void SluResponse::clear_started() {
  if (has_started()) {
    delete streaming_response_.started_;
    clear_has_streaming_response();
  }
}
inline const ::speechgrinder::sgapi::v1::SluStarted& SluResponse::_internal_started() const {
  return *streaming_response_.started_;
}
inline ::speechgrinder::sgapi::v1::SluStarted* SluResponse::release_started() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.SluResponse.started)
  if (has_started()) {
    clear_has_streaming_response();
      ::speechgrinder::sgapi::v1::SluStarted* temp = streaming_response_.started_;
    streaming_response_.started_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::speechgrinder::sgapi::v1::SluStarted& SluResponse::started() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.SluResponse.started)
  return has_started()
      ? *streaming_response_.started_
      : *reinterpret_cast< ::speechgrinder::sgapi::v1::SluStarted*>(&::speechgrinder::sgapi::v1::_SluStarted_default_instance_);
}
inline ::speechgrinder::sgapi::v1::SluStarted* SluResponse::mutable_started() {
  if (!has_started()) {
    clear_streaming_response();
    set_has_started();
    streaming_response_.started_ = CreateMaybeMessage< ::speechgrinder::sgapi::v1::SluStarted >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.SluResponse.started)
  return streaming_response_.started_;
}

// .speechgrinder.sgapi.v1.Utterance utterance = 2;
inline bool SluResponse::has_utterance() const {
  return streaming_response_case() == kUtterance;
}
inline void SluResponse::set_has_utterance() {
  _oneof_case_[0] = kUtterance;
}
inline void SluResponse::clear_utterance() {
  if (has_utterance()) {
    delete streaming_response_.utterance_;
    clear_has_streaming_response();
  }
}
inline const ::speechgrinder::sgapi::v1::Utterance& SluResponse::_internal_utterance() const {
  return *streaming_response_.utterance_;
}
inline ::speechgrinder::sgapi::v1::Utterance* SluResponse::release_utterance() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.SluResponse.utterance)
  if (has_utterance()) {
    clear_has_streaming_response();
      ::speechgrinder::sgapi::v1::Utterance* temp = streaming_response_.utterance_;
    streaming_response_.utterance_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::speechgrinder::sgapi::v1::Utterance& SluResponse::utterance() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.SluResponse.utterance)
  return has_utterance()
      ? *streaming_response_.utterance_
      : *reinterpret_cast< ::speechgrinder::sgapi::v1::Utterance*>(&::speechgrinder::sgapi::v1::_Utterance_default_instance_);
}
inline ::speechgrinder::sgapi::v1::Utterance* SluResponse::mutable_utterance() {
  if (!has_utterance()) {
    clear_streaming_response();
    set_has_utterance();
    streaming_response_.utterance_ = CreateMaybeMessage< ::speechgrinder::sgapi::v1::Utterance >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.SluResponse.utterance)
  return streaming_response_.utterance_;
}

// .speechgrinder.sgapi.v1.SluFinished finished = 3;
inline bool SluResponse::has_finished() const {
  return streaming_response_case() == kFinished;
}
inline void SluResponse::set_has_finished() {
  _oneof_case_[0] = kFinished;
}
inline void SluResponse::clear_finished() {
  if (has_finished()) {
    delete streaming_response_.finished_;
    clear_has_streaming_response();
  }
}
inline const ::speechgrinder::sgapi::v1::SluFinished& SluResponse::_internal_finished() const {
  return *streaming_response_.finished_;
}
inline ::speechgrinder::sgapi::v1::SluFinished* SluResponse::release_finished() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.SluResponse.finished)
  if (has_finished()) {
    clear_has_streaming_response();
      ::speechgrinder::sgapi::v1::SluFinished* temp = streaming_response_.finished_;
    streaming_response_.finished_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::speechgrinder::sgapi::v1::SluFinished& SluResponse::finished() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.SluResponse.finished)
  return has_finished()
      ? *streaming_response_.finished_
      : *reinterpret_cast< ::speechgrinder::sgapi::v1::SluFinished*>(&::speechgrinder::sgapi::v1::_SluFinished_default_instance_);
}
inline ::speechgrinder::sgapi::v1::SluFinished* SluResponse::mutable_finished() {
  if (!has_finished()) {
    clear_streaming_response();
    set_has_finished();
    streaming_response_.finished_ = CreateMaybeMessage< ::speechgrinder::sgapi::v1::SluFinished >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.SluResponse.finished)
  return streaming_response_.finished_;
}

inline bool SluResponse::has_streaming_response() const {
  return streaming_response_case() != STREAMING_RESPONSE_NOT_SET;
}
inline void SluResponse::clear_has_streaming_response() {
  _oneof_case_[0] = STREAMING_RESPONSE_NOT_SET;
}
inline SluResponse::StreamingResponseCase SluResponse::streaming_response_case() const {
  return SluResponse::StreamingResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SluStarted

// string utterance_id = 1;
inline void SluStarted::clear_utterance_id() {
  utterance_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SluStarted::utterance_id() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.SluStarted.utterance_id)
  return utterance_id_.GetNoArena();
}
inline void SluStarted::set_utterance_id(const ::std::string& value) {
  
  utterance_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.SluStarted.utterance_id)
}
#if LANG_CXX11
inline void SluStarted::set_utterance_id(::std::string&& value) {
  
  utterance_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.SluStarted.utterance_id)
}
#endif
inline void SluStarted::set_utterance_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  utterance_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.SluStarted.utterance_id)
}
inline void SluStarted::set_utterance_id(const char* value, size_t size) {
  
  utterance_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.SluStarted.utterance_id)
}
inline ::std::string* SluStarted::mutable_utterance_id() {
  
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.SluStarted.utterance_id)
  return utterance_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SluStarted::release_utterance_id() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.SluStarted.utterance_id)
  
  return utterance_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SluStarted::set_allocated_utterance_id(::std::string* utterance_id) {
  if (utterance_id != NULL) {
    
  } else {
    
  }
  utterance_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), utterance_id);
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.SluStarted.utterance_id)
}

// -------------------------------------------------------------------

// SluFinished

// string utterance_id = 1;
inline void SluFinished::clear_utterance_id() {
  utterance_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SluFinished::utterance_id() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.SluFinished.utterance_id)
  return utterance_id_.GetNoArena();
}
inline void SluFinished::set_utterance_id(const ::std::string& value) {
  
  utterance_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.SluFinished.utterance_id)
}
#if LANG_CXX11
inline void SluFinished::set_utterance_id(::std::string&& value) {
  
  utterance_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.SluFinished.utterance_id)
}
#endif
inline void SluFinished::set_utterance_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  utterance_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.SluFinished.utterance_id)
}
inline void SluFinished::set_utterance_id(const char* value, size_t size) {
  
  utterance_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.SluFinished.utterance_id)
}
inline ::std::string* SluFinished::mutable_utterance_id() {
  
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.SluFinished.utterance_id)
  return utterance_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SluFinished::release_utterance_id() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.SluFinished.utterance_id)
  
  return utterance_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SluFinished::set_allocated_utterance_id(::std::string* utterance_id) {
  if (utterance_id != NULL) {
    
  } else {
    
  }
  utterance_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), utterance_id);
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.SluFinished.utterance_id)
}

// .speechgrinder.sgapi.v1.SluError error = 2;
inline bool SluFinished::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void SluFinished::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
inline const ::speechgrinder::sgapi::v1::SluError& SluFinished::_internal_error() const {
  return *error_;
}
inline const ::speechgrinder::sgapi::v1::SluError& SluFinished::error() const {
  const ::speechgrinder::sgapi::v1::SluError* p = error_;
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.SluFinished.error)
  return p != NULL ? *p : *reinterpret_cast<const ::speechgrinder::sgapi::v1::SluError*>(
      &::speechgrinder::sgapi::v1::_SluError_default_instance_);
}
inline ::speechgrinder::sgapi::v1::SluError* SluFinished::release_error() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.SluFinished.error)
  
  ::speechgrinder::sgapi::v1::SluError* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::speechgrinder::sgapi::v1::SluError* SluFinished::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::speechgrinder::sgapi::v1::SluError>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.SluFinished.error)
  return error_;
}
inline void SluFinished::set_allocated_error(::speechgrinder::sgapi::v1::SluError* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.SluFinished.error)
}

// -------------------------------------------------------------------

// SluError

// string code = 1;
inline void SluError::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SluError::code() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.SluError.code)
  return code_.GetNoArena();
}
inline void SluError::set_code(const ::std::string& value) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.SluError.code)
}
#if LANG_CXX11
inline void SluError::set_code(::std::string&& value) {
  
  code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.SluError.code)
}
#endif
inline void SluError::set_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.SluError.code)
}
inline void SluError::set_code(const char* value, size_t size) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.SluError.code)
}
inline ::std::string* SluError::mutable_code() {
  
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.SluError.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SluError::release_code() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.SluError.code)
  
  return code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SluError::set_allocated_code(::std::string* code) {
  if (code != NULL) {
    
  } else {
    
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.SluError.code)
}

// string message = 2;
inline void SluError::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SluError::message() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.SluError.message)
  return message_.GetNoArena();
}
inline void SluError::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.SluError.message)
}
#if LANG_CXX11
inline void SluError::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.SluError.message)
}
#endif
inline void SluError::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.SluError.message)
}
inline void SluError::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.SluError.message)
}
inline ::std::string* SluError::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.SluError.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SluError::release_message() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.SluError.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SluError::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.SluError.message)
}

// -------------------------------------------------------------------

// Utterance

// string utterance_id = 1;
inline void Utterance::clear_utterance_id() {
  utterance_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Utterance::utterance_id() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.Utterance.utterance_id)
  return utterance_id_.GetNoArena();
}
inline void Utterance::set_utterance_id(const ::std::string& value) {
  
  utterance_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.Utterance.utterance_id)
}
#if LANG_CXX11
inline void Utterance::set_utterance_id(::std::string&& value) {
  
  utterance_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.Utterance.utterance_id)
}
#endif
inline void Utterance::set_utterance_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  utterance_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.Utterance.utterance_id)
}
inline void Utterance::set_utterance_id(const char* value, size_t size) {
  
  utterance_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.Utterance.utterance_id)
}
inline ::std::string* Utterance::mutable_utterance_id() {
  
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.Utterance.utterance_id)
  return utterance_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Utterance::release_utterance_id() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.Utterance.utterance_id)
  
  return utterance_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utterance::set_allocated_utterance_id(::std::string* utterance_id) {
  if (utterance_id != NULL) {
    
  } else {
    
  }
  utterance_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), utterance_id);
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.Utterance.utterance_id)
}

// string type = 2;
inline void Utterance::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Utterance::type() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.Utterance.type)
  return type_.GetNoArena();
}
inline void Utterance::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.Utterance.type)
}
#if LANG_CXX11
inline void Utterance::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.Utterance.type)
}
#endif
inline void Utterance::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.Utterance.type)
}
inline void Utterance::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.Utterance.type)
}
inline ::std::string* Utterance::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.Utterance.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Utterance::release_type() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.Utterance.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utterance::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.Utterance.type)
}

// string language_code = 3;
inline void Utterance::clear_language_code() {
  language_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Utterance::language_code() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.Utterance.language_code)
  return language_code_.GetNoArena();
}
inline void Utterance::set_language_code(const ::std::string& value) {
  
  language_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.Utterance.language_code)
}
#if LANG_CXX11
inline void Utterance::set_language_code(::std::string&& value) {
  
  language_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.Utterance.language_code)
}
#endif
inline void Utterance::set_language_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  language_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.Utterance.language_code)
}
inline void Utterance::set_language_code(const char* value, size_t size) {
  
  language_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.Utterance.language_code)
}
inline ::std::string* Utterance::mutable_language_code() {
  
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.Utterance.language_code)
  return language_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Utterance::release_language_code() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.Utterance.language_code)
  
  return language_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utterance::set_allocated_language_code(::std::string* language_code) {
  if (language_code != NULL) {
    
  } else {
    
  }
  language_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language_code);
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.Utterance.language_code)
}

// repeated .speechgrinder.sgapi.v1.Alternative alternatives = 4;
inline int Utterance::alternatives_size() const {
  return alternatives_.size();
}
inline void Utterance::clear_alternatives() {
  alternatives_.Clear();
}
inline ::speechgrinder::sgapi::v1::Alternative* Utterance::mutable_alternatives(int index) {
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.Utterance.alternatives)
  return alternatives_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::speechgrinder::sgapi::v1::Alternative >*
Utterance::mutable_alternatives() {
  // @@protoc_insertion_point(field_mutable_list:speechgrinder.sgapi.v1.Utterance.alternatives)
  return &alternatives_;
}
inline const ::speechgrinder::sgapi::v1::Alternative& Utterance::alternatives(int index) const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.Utterance.alternatives)
  return alternatives_.Get(index);
}
inline ::speechgrinder::sgapi::v1::Alternative* Utterance::add_alternatives() {
  // @@protoc_insertion_point(field_add:speechgrinder.sgapi.v1.Utterance.alternatives)
  return alternatives_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::speechgrinder::sgapi::v1::Alternative >&
Utterance::alternatives() const {
  // @@protoc_insertion_point(field_list:speechgrinder.sgapi.v1.Utterance.alternatives)
  return alternatives_;
}

// -------------------------------------------------------------------

// Alternative

// float confidence = 1;
inline void Alternative::clear_confidence() {
  confidence_ = 0;
}
inline float Alternative::confidence() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.Alternative.confidence)
  return confidence_;
}
inline void Alternative::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.Alternative.confidence)
}

// repeated .speechgrinder.sgapi.v1.Token tokens = 2;
inline int Alternative::tokens_size() const {
  return tokens_.size();
}
inline void Alternative::clear_tokens() {
  tokens_.Clear();
}
inline ::speechgrinder::sgapi::v1::Token* Alternative::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.Alternative.tokens)
  return tokens_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::speechgrinder::sgapi::v1::Token >*
Alternative::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:speechgrinder.sgapi.v1.Alternative.tokens)
  return &tokens_;
}
inline const ::speechgrinder::sgapi::v1::Token& Alternative::tokens(int index) const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.Alternative.tokens)
  return tokens_.Get(index);
}
inline ::speechgrinder::sgapi::v1::Token* Alternative::add_tokens() {
  // @@protoc_insertion_point(field_add:speechgrinder.sgapi.v1.Alternative.tokens)
  return tokens_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::speechgrinder::sgapi::v1::Token >&
Alternative::tokens() const {
  // @@protoc_insertion_point(field_list:speechgrinder.sgapi.v1.Alternative.tokens)
  return tokens_;
}

// -------------------------------------------------------------------

// Token

// string text = 1;
inline void Token::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Token::text() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.Token.text)
  return text_.GetNoArena();
}
inline void Token::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.Token.text)
}
#if LANG_CXX11
inline void Token::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.Token.text)
}
#endif
inline void Token::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.Token.text)
}
inline void Token::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.Token.text)
}
inline ::std::string* Token::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.Token.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_text() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.Token.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.Token.text)
}

// string text_with_trailing_space = 2;
inline void Token::clear_text_with_trailing_space() {
  text_with_trailing_space_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Token::text_with_trailing_space() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.Token.text_with_trailing_space)
  return text_with_trailing_space_.GetNoArena();
}
inline void Token::set_text_with_trailing_space(const ::std::string& value) {
  
  text_with_trailing_space_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.Token.text_with_trailing_space)
}
#if LANG_CXX11
inline void Token::set_text_with_trailing_space(::std::string&& value) {
  
  text_with_trailing_space_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.Token.text_with_trailing_space)
}
#endif
inline void Token::set_text_with_trailing_space(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_with_trailing_space_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.Token.text_with_trailing_space)
}
inline void Token::set_text_with_trailing_space(const char* value, size_t size) {
  
  text_with_trailing_space_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.Token.text_with_trailing_space)
}
inline ::std::string* Token::mutable_text_with_trailing_space() {
  
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.Token.text_with_trailing_space)
  return text_with_trailing_space_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_text_with_trailing_space() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.Token.text_with_trailing_space)
  
  return text_with_trailing_space_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_text_with_trailing_space(::std::string* text_with_trailing_space) {
  if (text_with_trailing_space != NULL) {
    
  } else {
    
  }
  text_with_trailing_space_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text_with_trailing_space);
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.Token.text_with_trailing_space)
}

// string lemma = 3;
inline void Token::clear_lemma() {
  lemma_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Token::lemma() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.Token.lemma)
  return lemma_.GetNoArena();
}
inline void Token::set_lemma(const ::std::string& value) {
  
  lemma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.Token.lemma)
}
#if LANG_CXX11
inline void Token::set_lemma(::std::string&& value) {
  
  lemma_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.Token.lemma)
}
#endif
inline void Token::set_lemma(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  lemma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.Token.lemma)
}
inline void Token::set_lemma(const char* value, size_t size) {
  
  lemma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.Token.lemma)
}
inline ::std::string* Token::mutable_lemma() {
  
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.Token.lemma)
  return lemma_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_lemma() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.Token.lemma)
  
  return lemma_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_lemma(::std::string* lemma) {
  if (lemma != NULL) {
    
  } else {
    
  }
  lemma_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lemma);
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.Token.lemma)
}

// string pos = 4;
inline void Token::clear_pos() {
  pos_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Token::pos() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.Token.pos)
  return pos_.GetNoArena();
}
inline void Token::set_pos(const ::std::string& value) {
  
  pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.Token.pos)
}
#if LANG_CXX11
inline void Token::set_pos(::std::string&& value) {
  
  pos_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.Token.pos)
}
#endif
inline void Token::set_pos(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.Token.pos)
}
inline void Token::set_pos(const char* value, size_t size) {
  
  pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.Token.pos)
}
inline ::std::string* Token::mutable_pos() {
  
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.Token.pos)
  return pos_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_pos() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.Token.pos)
  
  return pos_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_pos(::std::string* pos) {
  if (pos != NULL) {
    
  } else {
    
  }
  pos_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pos);
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.Token.pos)
}

// string tag = 5;
inline void Token::clear_tag() {
  tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Token::tag() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.Token.tag)
  return tag_.GetNoArena();
}
inline void Token::set_tag(const ::std::string& value) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.Token.tag)
}
#if LANG_CXX11
inline void Token::set_tag(::std::string&& value) {
  
  tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.Token.tag)
}
#endif
inline void Token::set_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.Token.tag)
}
inline void Token::set_tag(const char* value, size_t size) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.Token.tag)
}
inline ::std::string* Token::mutable_tag() {
  
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.Token.tag)
  return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_tag() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.Token.tag)
  
  return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_tag(::std::string* tag) {
  if (tag != NULL) {
    
  } else {
    
  }
  tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.Token.tag)
}

// string case = 6;
inline void Token::clear_case_() {
  case__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Token::case_() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.Token.case)
  return case__.GetNoArena();
}
inline void Token::set_case_(const ::std::string& value) {
  
  case__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.Token.case)
}
#if LANG_CXX11
inline void Token::set_case_(::std::string&& value) {
  
  case__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.Token.case)
}
#endif
inline void Token::set_case_(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  case__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.Token.case)
}
inline void Token::set_case_(const char* value, size_t size) {
  
  case__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.Token.case)
}
inline ::std::string* Token::mutable_case_() {
  
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.Token.case)
  return case__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_case_() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.Token.case)
  
  return case__.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_case_(::std::string* case_) {
  if (case_ != NULL) {
    
  } else {
    
  }
  case__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), case_);
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.Token.case)
}

// string number = 7;
inline void Token::clear_number() {
  number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Token::number() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.Token.number)
  return number_.GetNoArena();
}
inline void Token::set_number(const ::std::string& value) {
  
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.Token.number)
}
#if LANG_CXX11
inline void Token::set_number(::std::string&& value) {
  
  number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.Token.number)
}
#endif
inline void Token::set_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.Token.number)
}
inline void Token::set_number(const char* value, size_t size) {
  
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.Token.number)
}
inline ::std::string* Token::mutable_number() {
  
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.Token.number)
  return number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_number() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.Token.number)
  
  return number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_number(::std::string* number) {
  if (number != NULL) {
    
  } else {
    
  }
  number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), number);
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.Token.number)
}

// string entity_type = 8;
inline void Token::clear_entity_type() {
  entity_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Token::entity_type() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.Token.entity_type)
  return entity_type_.GetNoArena();
}
inline void Token::set_entity_type(const ::std::string& value) {
  
  entity_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.Token.entity_type)
}
#if LANG_CXX11
inline void Token::set_entity_type(::std::string&& value) {
  
  entity_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.Token.entity_type)
}
#endif
inline void Token::set_entity_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  entity_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.Token.entity_type)
}
inline void Token::set_entity_type(const char* value, size_t size) {
  
  entity_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.Token.entity_type)
}
inline ::std::string* Token::mutable_entity_type() {
  
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.Token.entity_type)
  return entity_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_entity_type() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.Token.entity_type)
  
  return entity_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_entity_type(::std::string* entity_type) {
  if (entity_type != NULL) {
    
  } else {
    
  }
  entity_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), entity_type);
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.Token.entity_type)
}

// .speechgrinder.sgapi.v1.Token.TokenPosition position_in_entity = 9;
inline void Token::clear_position_in_entity() {
  position_in_entity_ = 0;
}
inline ::speechgrinder::sgapi::v1::Token_TokenPosition Token::position_in_entity() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.Token.position_in_entity)
  return static_cast< ::speechgrinder::sgapi::v1::Token_TokenPosition >(position_in_entity_);
}
inline void Token::set_position_in_entity(::speechgrinder::sgapi::v1::Token_TokenPosition value) {
  
  position_in_entity_ = value;
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.Token.position_in_entity)
}

// bool is_segment_start = 10;
inline void Token::clear_is_segment_start() {
  is_segment_start_ = false;
}
inline bool Token::is_segment_start() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.Token.is_segment_start)
  return is_segment_start_;
}
inline void Token::set_is_segment_start(bool value) {
  
  is_segment_start_ = value;
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.Token.is_segment_start)
}

// int32 trailing_silence = 11;
inline void Token::clear_trailing_silence() {
  trailing_silence_ = 0;
}
inline ::google::protobuf::int32 Token::trailing_silence() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.Token.trailing_silence)
  return trailing_silence_;
}
inline void Token::set_trailing_silence(::google::protobuf::int32 value) {
  
  trailing_silence_ = value;
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.Token.trailing_silence)
}

// -------------------------------------------------------------------

// LoginRequest

// string device_id = 1;
inline void LoginRequest::clear_device_id() {
  device_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::device_id() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.LoginRequest.device_id)
  return device_id_.GetNoArena();
}
inline void LoginRequest::set_device_id(const ::std::string& value) {
  
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.LoginRequest.device_id)
}
#if LANG_CXX11
inline void LoginRequest::set_device_id(::std::string&& value) {
  
  device_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.LoginRequest.device_id)
}
#endif
inline void LoginRequest::set_device_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.LoginRequest.device_id)
}
inline void LoginRequest::set_device_id(const char* value, size_t size) {
  
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.LoginRequest.device_id)
}
inline ::std::string* LoginRequest::mutable_device_id() {
  
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.LoginRequest.device_id)
  return device_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_device_id() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.LoginRequest.device_id)
  
  return device_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id != NULL) {
    
  } else {
    
  }
  device_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_id);
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.LoginRequest.device_id)
}

// string app_id = 2;
inline void LoginRequest::clear_app_id() {
  app_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::app_id() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.LoginRequest.app_id)
  return app_id_.GetNoArena();
}
inline void LoginRequest::set_app_id(const ::std::string& value) {
  
  app_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.LoginRequest.app_id)
}
#if LANG_CXX11
inline void LoginRequest::set_app_id(::std::string&& value) {
  
  app_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.LoginRequest.app_id)
}
#endif
inline void LoginRequest::set_app_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  app_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.LoginRequest.app_id)
}
inline void LoginRequest::set_app_id(const char* value, size_t size) {
  
  app_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.LoginRequest.app_id)
}
inline ::std::string* LoginRequest::mutable_app_id() {
  
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.LoginRequest.app_id)
  return app_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_app_id() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.LoginRequest.app_id)
  
  return app_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_app_id(::std::string* app_id) {
  if (app_id != NULL) {
    
  } else {
    
  }
  app_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_id);
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.LoginRequest.app_id)
}

// -------------------------------------------------------------------

// LoginResponse

// string token = 1;
inline void LoginResponse::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginResponse::token() const {
  // @@protoc_insertion_point(field_get:speechgrinder.sgapi.v1.LoginResponse.token)
  return token_.GetNoArena();
}
inline void LoginResponse::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechgrinder.sgapi.v1.LoginResponse.token)
}
#if LANG_CXX11
inline void LoginResponse::set_token(::std::string&& value) {
  
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechgrinder.sgapi.v1.LoginResponse.token)
}
#endif
inline void LoginResponse::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechgrinder.sgapi.v1.LoginResponse.token)
}
inline void LoginResponse::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechgrinder.sgapi.v1.LoginResponse.token)
}
inline ::std::string* LoginResponse::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:speechgrinder.sgapi.v1.LoginResponse.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginResponse::release_token() {
  // @@protoc_insertion_point(field_release:speechgrinder.sgapi.v1.LoginResponse.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResponse::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:speechgrinder.sgapi.v1.LoginResponse.token)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace sgapi
}  // namespace speechgrinder

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::speechgrinder::sgapi::v1::SluConfig_Encoding> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::speechgrinder::sgapi::v1::SluConfig_Encoding>() {
  return ::speechgrinder::sgapi::v1::SluConfig_Encoding_descriptor();
}
template <> struct is_proto_enum< ::speechgrinder::sgapi::v1::SluEvent_Event> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::speechgrinder::sgapi::v1::SluEvent_Event>() {
  return ::speechgrinder::sgapi::v1::SluEvent_Event_descriptor();
}
template <> struct is_proto_enum< ::speechgrinder::sgapi::v1::Token_TokenPosition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::speechgrinder::sgapi::v1::Token_TokenPosition>() {
  return ::speechgrinder::sgapi::v1::Token_TokenPosition_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_sg_2eproto
